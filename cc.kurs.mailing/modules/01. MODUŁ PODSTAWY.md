Oto znacznie rozbudowana agenda **Modułu 1: Wprowadzenie i Fundamenty**, wzbogacona o praktyczne przykłady, "pro-tipy" oraz unikalne pomysły wyciągnięte z doświadczeń ekspertów i dokumentacji.

Celem tego modułu jest nie tylko instalacja, ale **zbudowanie mentalnego modelu** pracy z agentem oraz konfiguracja środowiska tak, aby od pierwszego dnia pracować wydajnie i bezpiecznie.

---

### **MODUŁ 1: Fundamenty i Konfiguracja Środowiska (Rozszerzona Agenda)**

#### **1.1. Czym naprawdę jest Claude Code? (Zmiana myślenia)**
*   **Koncepcja:** To nie jest kolejny czat w IDE (jak Copilot) ani tylko "nakładka na API". To **autonomiczny agent terminalowy**, który działa jak "bardzo szybki stażysta z doskonałą pamięcią".
*   **Kluczowa różnica:** Działa bezpośrednio w powłoce (shell), co oznacza, że może wykonywać komendy systemowe, zarządzać git-em i edytować pliki bezpośrednio na dysku, a nie tylko podpowiadać kod w edytorze.
*   **Analiza:** Dlaczego Claude Code jest określany jako "uniwersalny interfejs do komputera" – od zarządzania plikami po czyszczenie dysku i obsługę multimediów (np. ffmpeg).

**Praktyczne przykłady użycia:**
*   **Kod + DevOps:** `> Zaktualizuj wszystkie dependencje w package.json, przetestuj zmiany i stwórz commit`
*   **Czyszczenie projektu:** `> Znajdź i usuń wszystkie pliki .DS_Store oraz node_modules starsze niż 30 dni`
*   **Multimedia:** `> Skompresuj wszystkie pliki MP4 w folderze /videos używając ffmpeg do rozmiaru <10MB`
*   **Dokumentacja:** `> Wygeneruj README.md na podstawie analizy struktury projektu i package.json`
*   **Analiza logów:** `> Przeanalizuj logi z /var/log/nginx/ i pokaż top 10 najczęstszych błędów 5xx`

**Pro-tipy:**
*   **Myśl zadaniowo, nie komendowo:** Zamiast "uruchom npm install" powiedz "zainstaluj wszystkie zależności i napraw konflikty wersji jeśli wystąpią"
*   **Deleguj, nie instruuj:** Claude Code najlepiej pracuje gdy dostaje cel ("zoptymalizuj wydajność"), a nie szczegółowe kroki
*   **Używaj analogii:** "Zachowuj się jak senior developer robiący code review" działa lepiej niż lista techniczna

**Typowe błędy i jak ich unikać:**
*   ❌ **Błąd:** Traktowanie Claude jak chatbota - kopiowanie kodu ręcznie z odpowiedzi
    *   ✅ **Rozwiązanie:** Pozwól Claude edytować pliki bezpośrednio używając narzędzi Edit/Write
*   ❌ **Błąd:** Mikromanagement - podawanie dokładnych komend bash do wykonania
    *   ✅ **Rozwiązanie:** Opisz problem biznesowy, pozwól Claude wybrać narzędzia
*   ❌ **Błąd:** Zbyt ogólne polecenia typu "napraw projekt"
    *   ✅ **Rozwiązanie:** Dodaj kontekst: "Testy e2e failują na CI - znajdź przyczynę i napraw"

**Edge cases i scenariusze rzeczywiste:**
*   **Multi-język:** Claude radzi sobie z projektami polyglot (Python backend + React frontend + Terraform IaC)
*   **Legacy code:** Świetnie działa z kodem bez dokumentacji - potrafi zrekonstruować intencję z kodu
*   **Debugging produkcyjny:** Możesz wkleić stack trace z produkcji i Claude pomoże znaleźć źródło problemu w kodzie
*   **Migracje:** "Zmigruj z Webpack na Vite" - Claude przeprowadzi migrację analizując cały setup

**Kiedy Claude Code NIE jest odpowiednim narzędziem:**
*   Zadania wymagające długotrwałego działania (>10 min) - lepszy CI/CD pipeline
*   Operacje na bardzo dużych plikach binarnych (>100MB)
*   Zadania wymagające interaktywnej wizualizacji (debugger z breakpoints)

#### **1.2. Instalacja i Pierwsze Kroki (Beyond Basics)**
*   **Metody instalacji:**
    *   **Zalecana (Native):** `curl -fsSL https://claude.ai/install.sh | bash` (MacOS/Linux) – stabilniejsza, nie wymaga Node.js,.
    *   **NPM:** `npm install -g @anthropic-ai/claude-code` – pozwala na łatwiejsze zarządzanie wersjami, ale wymaga Node.js 18+,.
    *   **Windows:** Specyfika instalacji przez PowerShell (`irm ... | iex`) i pułapki związane z `npm` w systemie Windows.
*   **Rozwiązywanie problemów (Troubleshooting):**
    *   Użycie komendy `/doctor` do diagnozowania problemów z instalacją i połączeniem,.
    *   Naprawa problemów ze ścieżkami (PATH) w Windows i WSL,.
*   **Pro-Tip (Aliasy):** Skonfiguruj w `.zshrc` lub `.bashrc` aliasy, np. `alias c='claude'` lub `alias q='cd ~/Projects'`, aby przyspieszyć uruchamianie.

**Szczegółowe przykłady instalacji (krok po kroku):**

**MacOS (Homebrew - najłatwiejsza metoda):**
```bash
# Jeśli masz Homebrew (zalecane)
brew tap anthropic-ai/claude
brew install claude

# Weryfikacja instalacji
claude --version
which claude  # Powinno pokazać /opt/homebrew/bin/claude lub podobne
```

**Linux (Universal):**
```bash
# Instalacja przez oficjalny skrypt
curl -fsSL https://claude.ai/install.sh | bash

# Jeśli pojawi się błąd uprawnień, użyj:
curl -fsSL https://claude.ai/install.sh | sudo bash

# Dodanie do PATH (jeśli nie działa automatycznie)
echo 'export PATH="$HOME/.claude/bin:$PATH"' >> ~/.bashrc
source ~/.bashrc

# Dla zsh:
echo 'export PATH="$HOME/.claude/bin:$PATH"' >> ~/.zshrc
source ~/.zshrc
```

**Windows (PowerShell jako Administrator):**
```powershell
# Metoda 1: Oficjalny skrypt (zalecane)
irm https://claude.ai/install.ps1 | iex

# Metoda 2: NPM (jeśli masz Node.js)
npm install -g @anthropic-ai/claude-code

# Weryfikacja
claude --version
```

**Pro-tipy instalacyjne:**
*   **Wersjonowanie:** Używaj NPM jeśli potrzebujesz zarządzać wieloma wersjami Claude (`nvm use 18 && npm install -g claude`)
*   **Automatyczna aktualizacja:** Dodaj do `.zshrc`: `alias claude-update='brew upgrade claude'` (macOS) lub `npm update -g @anthropic-ai/claude-code` (NPM)
*   **Izolacja środowisk:** Używaj `asdf` lub `mise` do zarządzania wersjami narzędzi CLI obok Node.js
*   **Offline sprawdzenie:** Po instalacji uruchom `claude --help` (nie wymaga połączenia internetowego)

**Typowe błędy instalacji i rozwiązania:**

| Problem | Objaw | Rozwiązanie |
|---------|-------|-------------|
| **Brak uprawnień** | `Permission denied` podczas instalacji | Użyj `sudo` LUB zainstaluj do katalogu użytkownika (`npm config set prefix ~/.local`) |
| **Node.js za stary** | `Error: Unsupported Node version` | Zaktualizuj Node: `nvm install --lts` lub `brew upgrade node` |
| **PATH nie skonfigurowany** | `command not found: claude` | Dodaj do `.bashrc`/`.zshrc`: `export PATH="$HOME/.claude/bin:$PATH"` |
| **Windows Defender blokuje** | Instalacja zawiesza się na Windows | Tymczasowo wyłącz Real-time Protection lub dodaj wyjątek dla `%APPDATA%\npm` |
| **SSL Certificate Error** | `unable to verify the first certificate` | Ustaw `NODE_TLS_REJECT_UNAUTHORIZED=0` (tylko do celów testowych!) LUB zaktualizuj certyfikaty: `npm config set cafile /path/to/cert.pem` |
| **NPM cache corrupted** | Dziwne błędy podczas `npm install` | Wyczyść cache: `npm cache clean --force` i spróbuj ponownie |

**Troubleshooting zaawansowany:**

```bash
# Pełna diagnostyka instalacji
claude /doctor

# Sprawdzenie konfiguracji
claude /settings

# Resetowanie instalacji (nuclear option)
# macOS/Linux:
rm -rf ~/.claude
npm uninstall -g @anthropic-ai/claude-code
# Reinstalacja od nowa

# Windows:
Remove-Item -Recurse -Force $env:APPDATA\claude
npm uninstall -g @anthropic-ai/claude-code
```

**Konfiguracja zaawansowanych aliasów (.zshrc / .bashrc):**
```bash
# Podstawowe aliasy
alias c='claude'
alias cc='claude --compact'  # Uruchom z auto-compact
alias cdoc='claude /doctor'  # Szybka diagnostyka

# Aliasy projektowe (przeskakiwanie + uruchomienie)
alias cwork='cd ~/Projects/work && claude'
alias cpers='cd ~/Projects/personal && claude'

# Alias z automatycznym logowaniem (wymaga ANTHROPIC_API_KEY w .env)
alias capi='ANTHROPIC_API_KEY=$(cat ~/.anthropic) claude'

# Funkcja pomocnicza - uruchom Claude w konkretnym projekcie
cproj() {
    cd ~/Projects/"$1" && claude
}
# Użycie: cproj my-app

# Auto-update przy starcie powłoki (raz dziennie)
if [ ! -f ~/.claude_last_update ] || [ $(($(date +%s) - $(date -r ~/.claude_last_update +%s))) -gt 86400 ]; then
    brew upgrade claude 2>/dev/null || npm update -g @anthropic-ai/claude-code 2>/dev/null
    touch ~/.claude_last_update
fi
```

**Edge case: Instalacja w środowiskach korporacyjnych:**
*   **Proxy firmowe:** Skonfiguruj `HTTP_PROXY` i `HTTPS_PROXY` przed instalacją
    ```bash
    export HTTP_PROXY=http://proxy.company.com:8080
    export HTTPS_PROXY=http://proxy.company.com:8080
    npm install -g @anthropic-ai/claude-code
    ```
*   **Ograniczony dostęp do internetu:** Pobierz paczkę offline: `npm pack @anthropic-ai/claude-code` i zainstaluj lokalnie
*   **Brak sudo:** Użyj instalacji lokalnej:
    ```bash
    npm config set prefix ~/.local
    npm install -g @anthropic-ai/claude-code
    export PATH="$HOME/.local/bin:$PATH"
    ```

#### **1.3. Uwierzytelnianie i Modele Rozliczeń**
*   **Dwa światy:**
    *   **Konto Claude.ai (Pro/Team):** Stała opłata, limity wiadomości. Dobre na start i do przewidywalnych kosztów.
    *   **Claude Console (API):** Płatność za tokeny ("Pay-as-you-go"). Niezbędne do intensywnej pracy, integracji CI/CD i unikania kolejek w godzinach szczytu.
*   **Zarządzanie sesją:** Komendy `/login` i `/logout` do przełączania się między kontem prywatnym a firmowym.
*   **Ciekawy pomysł:** Ustawienie zmiennej środowiskowej `ANTHROPIC_API_KEY` w pliku `.env` lub profilu powłoki, aby uniknąć interaktywnego logowania (przydatne w skryptach).

**Praktyczne przykłady uwierzytelniania:**

**Metoda 1: Interaktywne logowanie (najprostsza):**
```bash
# Uruchom Claude i zaloguj się
claude

# W REPL wpisz:
/login

# Zostaniesz przekierowany do przeglądarki, gdzie:
# 1. Zaloguj się na claude.ai
# 2. Autoryzuj Claude Code
# 3. Skopiuj kod autoryzacyjny
# 4. Wklej kod w terminalu
```

**Metoda 2: API Key (dla zaawansowanych):**
```bash
# Pobierz klucz API z: https://console.anthropic.com/settings/keys

# Metoda A: Zmienna środowiskowa (tymczasowa, dla sesji)
export ANTHROPIC_API_KEY='sk-ant-api03-...'
claude

# Metoda B: Plik .env w projekcie (zalecane dla projektów)
echo "ANTHROPIC_API_KEY=sk-ant-api03-..." >> .env
echo ".env" >> .gitignore  # WAŻNE: Nie commituj klucza!
claude

# Metoda C: Globalny plik konfiguracyjny (dla wszystkich projektów)
mkdir -p ~/.config/claude
echo "ANTHROPIC_API_KEY=sk-ant-api03-..." > ~/.config/claude/config
chmod 600 ~/.config/claude/config  # Zabezpiecz plik
```

**Metoda 3: Zarządzanie wieloma kontami (firmowe + prywatne):**
```bash
# Stwórz profile w ~/.zshrc lub ~/.bashrc
alias claude-work='ANTHROPIC_API_KEY=$(cat ~/.anthropic-work) claude'
alias claude-personal='ANTHROPIC_API_KEY=$(cat ~/.anthropic-personal) claude'

# Przełączanie w REPL:
/logout              # Wyloguj się
/login               # Zaloguj na inne konto

# Sprawdzenie aktywnego konta:
/settings            # Pokaże email zalogowanego użytkownika
```

**Porównanie modeli rozliczeniowych:**

| Aspekt | Claude.ai Pro ($20/mies) | Console API (Pay-as-you-go) |
|--------|--------------------------|------------------------------|
| **Koszt** | Stały, przewidywalny | Zmienny, ~$3-15/mln tokenów |
| **Limity** | ~500 wiadomości/dzień (Sonnet 4.5) | Praktycznie nielimitowane |
| **Rate limit** | Kolejki w godzinach szczytu | Wyższy priorytet |
| **Najlepsze dla** | Osobisty development, nauka | Produkcja, CI/CD, zespoły |
| **Billing** | Karta kredytowa, miesięcznie | Kredyty prepaid + usage alerts |
| **Dostęp do modeli** | Sonnet, Opus, Haiku | Wszystkie + early access |

**Pro-tipy zarządzania kosztami:**

*   **Monitoruj zużycie:** Używaj `/cost` po każdej dłuższej sesji, aby śledzić wydatki
    ```bash
    > /cost
    # Przykładowy output:
    # Session cost: $0.23
    # Tokens: 45,234 input / 12,891 output
    # Model: claude-sonnet-4.5
    ```

*   **Ustaw alerty w Console:** Skonfiguruj powiadomienia email przy limicie $50, $100, $200

*   **Wybieraj model świadomie:**
    *   Haiku: Proste zadania, refactoring - ~$0.25/1M tokenów (tani)
    *   Sonnet 4.5: Większość pracy dev - ~$3/1M tokenów (optymalny)
    *   Opus 4.5: Architektura, trudne problemy - ~$15/1M tokenów (drogi, ale potężny)

*   **Kompresuj kontekst:** Używaj `/compact` przed długimi sesjami, aby zmniejszyć zużycie tokenów

**Typowe błędy uwierzytelniania i rozwiązania:**

| Problem | Objaw | Rozwiązanie |
|---------|-------|-------------|
| **401 Unauthorized** | `Error: Invalid API key` | Sprawdź czy klucz jest poprawny i aktywny w Console |
| **429 Rate Limited** | `Error: Too many requests` | Poczekaj 60s LUB przełącz się na konto API (wyższe limity) |
| **Browser nie otwiera się** | `/login` nie przekierowuje | Skopiuj URL z terminala i otwórz ręcznie w przeglądarce |
| **Token expired** | `Error: Session expired` | Uruchom `/logout` a następnie `/login` ponownie |
| **Konto Pro nie działa w Claude Code** | `Error: Subscription not found` | Upewnij się że subskrypcja jest aktywna na claude.ai/account |
| **API Key w repo!** | Przypadkowy commit klucza | NATYCHMIAST: revoke key w Console, usuń z historii git (`git filter-branch`) |

**Edge cases i scenariusze rzeczywiste:**

*   **Praca w zespole:** Stwórz Organization w Console, dodaj członków, ustaw shared billing
    ```bash
    # Każdy członek zespołu używa tego samego API key
    # Koszty agregowane na poziomie organizacji
    # Możliwość ustawienia budżetów per-user
    ```

*   **CI/CD integration:** Użyj API key jako GitHub Secret
    ```yaml
    # .github/workflows/claude.yml
    - name: Run Claude Code
      env:
        ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      run: |
        echo "Analyze code and suggest improvements" | claude --non-interactive
    ```

*   **Rotacja kluczy (security best practice):**
    ```bash
    # Co 90 dni:
    # 1. Wygeneruj nowy klucz w Console
    # 2. Zaktualizuj wszystkie miejsca (CI/CD, local env)
    # 3. Revoke stary klucz po 7 dniach grace period
    ```

*   **Sandbox testing:** Używaj konta Pro do testów, API do produkcji
    ```bash
    # Development: bezpłatny limit Pro
    alias claude-dev='claude'  # Używa konta Pro przez /login

    # Production/CI: płatne API z higher limits
    alias claude-prod='ANTHROPIC_API_KEY=$PROD_KEY claude'
    ```

**Troubleshooting zaawansowany - problemy z połączeniem:**

```bash
# Test połączenia z API
curl https://api.anthropic.com/v1/messages \
  -H "x-api-key: $ANTHROPIC_API_KEY" \
  -H "anthropic-version: 2023-06-01" \
  -H "content-type: application/json" \
  -d '{"model":"claude-sonnet-4.5","max_tokens":10,"messages":[{"role":"user","content":"Hi"}]}'

# Jeśli zwraca 200 OK - problem jest w Claude Code, nie w API
# Jeśli zwraca 401/403 - problem z kluczem
# Jeśli timeout - problem z siecią/firewall

# Sprawdzenie czy klucz jest ważny
claude /doctor

# Debug mode (pokaże szczegóły requestów)
CLAUDE_DEBUG=1 claude
```

**Kalkulator kosztów (quick reference):**

Typowa sesja kodowania (1h):
- **Sonnet 4.5:** ~50k input + 15k output tokens = ~$0.20
- **Opus 4.5:** ~50k input + 15k output tokens = ~$1.00

Miesięczne użycie (20h/tydz):
- **Sonnet:** ~$16/miesiąc (tańsze niż Pro!)
- **Opus:** ~$80/miesiąc (dla wymagających projektów)

**Wniosek:** Dla większości developerów Console API jest tańsze niż Pro plan gdy używasz głównie Sonnet!

#### **1.4. Interfejs REPL i "Jakość Życia" w Terminalu**
*   **Skróty klawiszowe (Mastery):**
    *   `Esc`: Przerwanie generowania (gdy agent "popłynie").
    *   `Esc` (x2): Szybki powrót do edycji ostatniego promptu (tzw. tryb korekty),.
    *   `Ctrl+R`: Przeszukiwanie historii komend (jak w bashu).
    *   `Ctrl+G`: Otwarcie promptu w zewnętrznym edytorze (np. Vim/VS Code) dla długich poleceń.
*   **Naprawa terminala:** Użycie `/terminal-setup` (lub konfiguracja VS Code), aby naprawić obsługę `Shift+Enter` (nowa linia) zamiast wysyłania wiadomości,.
*   **Personalizacja (Status Line):** Konfiguracja dolnego paska statusu, aby pokazywał zużycie tokenów, koszt sesji ($), aktualny branch gita i stan "brudnego" repozytorium.
    *   *Przykład:* Skrypt bash wyświetlający pasek postępu zużycia kontekstu (np. `█░░░░ 12%`),.

**Kompletna lista skrótów klawiaturowych:**

| Skrót | Akcja | Kiedy użyć |
|-------|-------|------------|
| `Esc` | Zatrzymaj generowanie | Gdy Claude "halucynuje" lub poszedł w złym kierunku |
| `Esc Esc` (2x) | Edytuj ostatni prompt | Literówka w prompcie lub chcesz doprecyzować |
| `Ctrl+C` | Anuluj obecną operację | Przerwij długotrwałe wykonywanie bash command |
| `Ctrl+D` | Wyjdź z Claude Code | Koniec sesji (zapisz historię) |
| `Ctrl+R` | Szukaj w historii | Przypomnij sobie poprzedni prompt |
| `Ctrl+G` | Edytuj w zewnętrznym edytorze | Długie prompty lub template'y |
| `Shift+Enter` | Nowa linia w prompcie | Multi-line prompts (wymaga konfiguracji) |
| `Tab` | Autocomplete @files | Szybkie referencje do plików |
| `Ctrl+L` | Wyczyść ekran | Odświeżenie widoku (nie czyści historii) |
| `Up/Down` | Historia promptów | Nawigacja po poprzednich komendach |

**Praktyczne przykłady użycia skrótów:**

```bash
# Scenario 1: Przerwanie złego kierunku
> Zrefaktoruj cały projekt używając pattern X
[Claude zaczyna zmieniać wszystko...]
<Esc>  # STOP! Za dużo zmian naraz

> Zacznij od zrefaktorowania tylko @src/utils/

# Scenario 2: Poprawka literówki
> Dodaj testy dla @src/auth.tss  # Ups, .tss zamiast .ts
<Esc><Esc>  # Wróć do edycji
> Dodaj testy dla @src/auth.ts  # Poprawione

# Scenario 3: Wyszukiwanie w historii
<Ctrl+R>
(reverse-i-search): migration  # Wpisz słowo kluczowe
# Znajdzie: "Przeprowadź migrację bazy danych z Postgres na MySQL"

# Scenario 4: Długi prompt w edytorze
<Ctrl+G>
# Otwiera się Vim/VS Code z:
# 1. Możliwością pisania w wielu liniach
# 2. Syntax highlighting dla kodu w promptach
# 3. Zapisz i zamknij -> prompt zostaje wysłany
```

**Konfiguracja terminala dla optymalnej pracy:**

**1. Napraw Shift+Enter (nowa linia bez wysyłania):**
```bash
# Dla iTerm2 (macOS):
# Preferences -> Keys -> Key Bindings -> +
# Keyboard Shortcut: Shift+Enter
# Action: Send Text: \n

# Dla Windows Terminal:
# settings.json:
{
  "keybindings": [
    { "command": "newLine", "keys": "shift+enter" }
  ]
}

# Dla VS Code integrated terminal:
# keybindings.json:
{
  "key": "shift+enter",
  "command": "workbench.action.terminal.sendSequence",
  "args": { "text": "\n" }
}
```

**2. Konfiguracja zewnętrznego edytora (Ctrl+G):**
```bash
# Dodaj do ~/.zshrc lub ~/.bashrc

# VS Code jako edytor
export EDITOR="code --wait"
export VISUAL="code --wait"

# Vim jako edytor (dla purystów)
export EDITOR="vim"
export VISUAL="vim"

# Nano (dla początkujących)
export EDITOR="nano"
export VISUAL="nano"

# Po zmianie:
source ~/.zshrc
```

**3. Personalizacja statusu (Advanced):**
```bash
# Stwórz ~/.config/claude/statusline.sh
#!/bin/bash

# Funkcja pokazująca current git branch i dirty state
git_info() {
    if git rev-parse --git-dir > /dev/null 2>&1; then
        branch=$(git branch --show-current)
        dirty=$(git status --porcelain | wc -l)
        if [ "$dirty" -gt 0 ]; then
            echo "[$branch *$dirty]"
        else
            echo "[$branch]"
        fi
    fi
}

# Eksportuj funkcję
export -f git_info

# Dodaj do PS1 (prompt) w ~/.zshrc:
# PS1='%F{cyan}$(git_info)%f %F{yellow}$%f '
```

**Pro-tipy dla wydajnej pracy w REPL:**

*   **History search master:** Używaj `Ctrl+R` + słowo kluczowe zamiast scrollowania
    *   Przykład: `Ctrl+R` -> wpisz "docker" -> znajdzie wszystkie prompty z docker

*   **Template prompts:** Stwórz plik `~/.claude/templates.md` z często używanymi promptami:
    ```markdown
    # Template: Code Review
    Przeanalizuj @{file} pod kątem:
    - Bezpieczeństwa (SQL injection, XSS)
    - Performance bottlenecks
    - Code smells i violations DRY

    # Template: Test Generation
    Wygeneruj testy jednostkowe dla @{file} używając Jest
    Coverage: 100%
    Edge cases: invalid input, null, undefined
    ```
    *   Użycie: Skopiuj template, zamień `{file}` na prawdziwą ścieżkę

*   **Clipboard integration:** Używaj `pbcopy` (macOS) / `xclip` (Linux) z Claude:
    ```bash
    # Skopiuj output Claude do clipboard
    > Wygeneruj UUID | pbcopy

    # Wklej clipboard jako input
    > Przeanalizuj ten error: $(pbpaste)
    ```

*   **Multi-line prompts bez Shift+Enter:**
    ```bash
    # Metoda 1: Użyj Ctrl+G -> edytor
    # Metoda 2: Wklej tekst z wielu linii (Ctrl+V)
    # Metoda 3: Użyj heredoc w bash:
    cat <<'EOF' | claude
    Wykonaj następujące kroki:
    1. Uruchom testy
    2. Napraw failures
    3. Stwórz commit
    EOF
    ```

**Typowe problemy z REPL i rozwiązania:**

| Problem | Objaw | Rozwiązanie |
|---------|-------|-------------|
| **Shift+Enter wysyła zamiast nowej linii** | Nie można pisać multi-line | Skonfiguruj terminal (patrz wyżej) |
| **Ctrl+R nie działa** | Brak przeszukiwania historii | Sprawdź czy używasz bash/zsh (nie fish/powershell) |
| **Ctrl+G otwiera złą aplikację** | Notepad zamiast VS Code | Ustaw `EDITOR` i `VISUAL` w profilu powłoki |
| **Polskie znaki się sypią** | ąćęłńóśźż wyświetlają jako ??? | Ustaw `export LANG=pl_PL.UTF-8` w ~/.zshrc |
| **Historia się nie zapisuje** | Po restarcie brak poprzednich promptów | Sprawdź uprawnienia `~/.claude/history` (chmod 644) |
| **Kolorowanie nie działa** | Monochromatyczny output | Włącz `export CLAUDE_COLORS=1` lub sprawdź `$TERM` |

**Edge cases i zaawansowane scenariusze:**

*   **Praca przez SSH:** Claude Code działa przez SSH, ale:
    ```bash
    # Forwarding autoryzacji (jeśli używasz API key)
    ssh -A user@server
    export ANTHROPIC_API_KEY="sk-ant-..."
    claude

    # Dla /login przez SSH (wymaga port forwarding):
    ssh -L 8080:localhost:8080 user@server
    # Przeglądarka otworzy się lokalnie
    ```

*   **Tmux/Screen integration:**
    ```bash
    # Stwórz dedykowaną sesję Claude
    tmux new -s claude
    claude

    # Detach: Ctrl+B D
    # Reattach: tmux attach -t claude

    # Pro-tip: Podziel ekran (kod + Claude)
    tmux split-window -h "vim"
    # Lewe okno: kod w Vim
    # Prawe okno: Claude Code
    ```

*   **Logging sesji do pliku:**
    ```bash
    # Loguj całą konwersację
    script -q /tmp/claude-session-$(date +%Y%m%d).log claude

    # Później możesz przeglądać:
    less /tmp/claude-session-20241228.log
    ```

*   **Integracja z Raycast/Alfred (macOS):**
    ```bash
    # Raycast Script Command: claude-quick.sh
    #!/bin/bash
    # Required parameters:
    # @raycast.schemaVersion 1
    # @raycast.title Quick Claude
    # @raycast.mode silent

    echo "$1" | claude --non-interactive
    ```

**Tips & Tricks dla power users:**

*   **Szybkie przełączanie projektów:**
    ```bash
    # Funkcja w ~/.zshrc
    ccd() {
        cd "$1" && claude
    }

    # Użycie:
    ccd ~/Projects/my-app  # CD + uruchom Claude
    ```

*   **Auto-save conversation:**
    ```bash
    # Alias zapisujący historię przed wyjściem
    alias cexit='claude /export session.md && exit'
    ```

*   **Clipboard hotkey (macOS BetterTouchTool):**
    - Zaznacz kod w edytorze
    - Naciśnij `Cmd+Shift+C`
    - Automatycznie kopiuje + uruchamia: `claude "Wyjaśnij ten kod: $(pbpaste)"`

*   **Notification po długich operacjach:**
    ```bash
    # Dodaj do CLAUDE.md:
    When a task takes >2 minutes, send system notification:
    `osascript -e 'display notification "Task completed" with title "Claude Code"'`
    ```

#### **1.4a. Referencje do Plików i Katalogów (@-syntax) – Klucz do Efektywnej Pracy**
*   **Podstawowa składnia (@file):** Używanie prefiksu `@` do automatycznego dołączania zawartości plików do kontekstu rozmowy.
    *   **Przykład:** `> Wyjaśnij co robi @src/auth.js` – Claude automatycznie odczyta plik i wyjaśni jego działanie.
    *   **Zaleta:** Nie musisz ręcznie kopiować i wklejać kodu – Claude sam go przeczyta i zindeksuje.
*   **Zakresy linii (@file#L10-20):** Precyzyjne wskazanie konkretnych linii kodu do analizy.
    *   **Przykład:** `> Zrefaktoruj @src/components/Header.tsx#L45-89` – Claude skupi się tylko na wskazanych liniach.
    *   **Use case:** Świetne do code review konkretnych funkcji lub bloków logiki bez zaśmiecania kontekstu całym plikiem.
    *   **Pro-Tip:** Możesz łączyć wiele zakresów: `@file.js#L10-20 @file.js#L100-120`.
*   **Referencje do katalogów (@dir/):** Dołączanie całych folderów do kontekstu (ostrożnie z rozmiarem!).
    *   **Przykład:** `> Przeanalizuj strukturę @src/components/` – Claude pobierze listę plików i może zaproponować refaktoryzację.
    *   **Ostrzeżenie:** Katalogi z dużą ilością plików mogą szybko zużyć limit tokenów. Używaj selektywnie.
    *   **Strategia:** Zamiast `@src/` użyj bardziej precyzyjnych ścieżek jak `@src/components/` lub `@src/utils/`.
*   **Wielokrotne referencje:** Możesz łączyć wiele plików i katalogów w jednym prompcie.
    *   **Przykład:** `> Porównaj @src/auth.ts z @src/middleware/jwt.ts i zaproponuj ujednolicenie` – Claude zobaczy oba pliki.
    *   **Advanced:** `> Zrefaktoruj @src/api/ używając wzorców z @docs/architecture.md`.
*   **Autocomplete (Szybszy workflow):**
    *   Po wpisaniu `@` Claude automatycznie podpowiada dostępne pliki z bieżącego katalogu.
    *   Użyj `Tab` do autouzupełniania ścieżek (jak w terminalu).
*   **Sztuczki i ograniczenia:**
    *   **Binarne pliki:** Claude może odczytywać obrazy (PNG, JPG) i PDF-y – możesz napisać `@screenshot.png` i zapytać "Co widzisz na tym ekranie?".
    *   **Limit rozmiaru:** Bardzo duże pliki (>100KB) mogą być automatycznie pomijane lub obcinane. Używaj zakresów linii dla dużych plików.
    *   **Relatywne ścieżki:** `@` działa z ścieżkami względnymi do aktualnego katalogu roboczego. Możesz użyć `@../` do wyjścia poziom wyżej.

**Praktyczne przykłady @-syntax (od podstaw do zaawansowanych):**

**Level 1: Podstawy - Pojedynczy plik**
```bash
# Analiza pojedynczego pliku
> Przeanalizuj @src/index.js i wyjaśnij co robi

# Code review
> Sprawdź @api/users.ts pod kątem bezpieczeństwa

# Dodanie feature
> Dodaj obsługę paginacji do @src/components/Table.tsx

# Debugging
> Dlaczego @tests/auth.test.js failuje? Napraw błędy
```

**Level 2: Zakresy linii - Precyzja**
```bash
# Refaktoryzacja konkretnej funkcji (linie 45-89)
> Zrefaktoruj @src/utils/validation.ts#L45-89 używając Zod

# Code review fragmentu
> Oceń complexity @src/services/payment.js#L120-250

# Optymalizacja bottlenecku
> Ta pętla jest wolna @src/algorithms/sort.py#L34-56, zoptymalizuj

# Wyjaśnienie pojedynczej funkcji
> Wyjaśnij co robi ta funkcja @lib/crypto.go#L78-95
```

**Level 3: Wielokrotne referencje - Porównania i migracje**
```bash
# Porównanie implementacji
> Porównaj @src/auth-old.ts z @src/auth-new.ts i pokaż różnice

# Spójność API
> Upewnij się że @api/v1/users.ts i @api/v2/users.ts mają kompatybilne interfejsy

# Migracja wzorca
> Zmień @src/components/Button.jsx z class component na functional używając wzorca z @src/components/Input.jsx

# Synchronizacja testów z kodem
> Dodaj brakujące testy w @tests/api.test.ts dla wszystkich endpointów z @src/api/routes.ts
```

**Level 4: Katalogi - Analiza architektury**
```bash
# Analiza struktury
> Przeanalizuj @src/components/ i zaproponuj lepszą organizację

# Refaktoryzacja modułowa
> Przenieś wszystkie utils z @src/components/ do @src/utils/

# Audit zależności
> Znajdź circular dependencies w @src/services/

# Generowanie dokumentacji
> Wygeneruj README.md dla @src/api/ opisujący wszystkie endpointy
```

**Level 5: Advanced - Kombinacje i wzorce**
```bash
# Migracja z dokumentacją
> Zmigruj @src/old-api/ do nowego wzorca opisanego w @docs/api-guidelines.md

# Multi-file refactoring
> Zastąp wszystkie wystąpienia starego API w @src/components/ @src/pages/ @src/hooks/

# Cross-reference testing
> Sprawdź czy wszystkie komponenty w @src/components/ mają testy w @tests/components/

# Architektura + implementation
> Zaimplementuj feature opisany w @docs/feature-spec.md modyfikując @src/core/
```

**Pro-tipy dla @-syntax:**

*   **Autocomplete master:** Wpisz `@` i zacznij pisać - Tab autocomplete działa jak w terminalu
    ```bash
    @sr<Tab>        # Uzupełni do @src/
    @src/co<Tab>    # Uzupełni do @src/components/
    ```

*   **Wildcards (jeśli wspierane):** Niektóre wersje pozwalają na:
    ```bash
    > Przeanalizuj wszystkie testy @tests/**/*.test.ts
    ```

*   **Łączenie z grep:** Znajdź pliki i referencuj je
    ```bash
    # Najpierw znajdź:
    > Znajdź wszystkie pliki z 'TODO' komentarzami
    # Claude pokaże listę
    # Potem:
    > Napraw wszystkie TODO w @src/utils/helpers.js @src/api/auth.ts
    ```

*   **Screenshot analysis:** Wklej screenshot lub drag&drop
    ```bash
    > @screenshot.png - zaimplementuj ten design
    > @error-console.png - co oznacza ten błąd?
    > @figma-export.png - stwórz CSS dla tego layoutu
    ```

*   **PDF documentation:**
    ```bash
    > Przeczytaj @docs/api-spec.pdf i zaimplementuj endpoints
    > @manual.pdf strona 45 - jak skonfigurować tę feature?
    ```

**Typowe błędy i rozwiązania:**

| Błąd | Objaw | Rozwiązanie |
|------|-------|-------------|
| **Plik nie znaleziony** | `Error: File not found @src/missing.js` | Sprawdź ścieżkę (użyj `ls` lub `find`), upewnij się że jesteś w root projektu |
| **Za duży kontekst** | `Warning: Context size exceeded` | Użyj zakresów linii `#L10-50` zamiast całego pliku |
| **Brak autocomplete** | `@` nie pokazuje podpowiedzi | Sprawdź czy jesteś w katalogu projektu, nie w `~/` |
| **Binary file error** | `Cannot read binary file` | Niektóre binaries nie są wspierane - użyj tylko PNG/JPG/PDF |
| **Relatywna ścieżka błąd** | `@../../../file.js` nie działa | Użyj absolutnej ścieżki lub cd do właściwego katalogu |
| **Zakres linii overflow** | `@file.js#L1-99999` | Sprawdź rzeczywistą długość pliku: `wc -l file.js` |

**Edge cases i zaawansowane scenariusze:**

*   **Pliki spoza projektu (sandbox bypass):**
    ```bash
    # Normalnie sandbox blokuje, ale możesz:
    > Przeanalizuj plik (pokazuje prompt o uprawnienia)
    # Odpowiedz 's' (show), sprawdź czy bezpieczne, potem 'y' (yes)

    # Alternatywnie: skopiuj plik do projektu
    cp ~/external-file.js ./temp/
    > Przeanalizuj @temp/external-file.js
    ```

*   **Analiza historii git:**
    ```bash
    # Sprawdź jak plik się zmienił
    git show HEAD~5:src/auth.ts > /tmp/auth-old.ts
    cp src/auth.ts /tmp/auth-new.ts

    > Porównaj @/tmp/auth-old.ts z @/tmp/auth-new.ts i wyjaśnij zmiany
    ```

*   **Diff analysis:**
    ```bash
    # Wygeneruj diff i przeanalizuj
    git diff > /tmp/changes.diff
    > Zrób code review @/tmp/changes.diff
    ```

*   **Multi-repository refactoring:**
    ```bash
    # Jeśli masz 2 projekty obok siebie
    > Skopiuj wzorzec z @../other-project/src/pattern.ts do @src/
    ```

*   **Nested archives (ZIP/TAR):**
    ```bash
    # Rozpakuj najpierw
    unzip package.zip -d /tmp/package/
    > Przeanalizuj strukturę @/tmp/package/
    ```

**Optymalizacja zużycia tokenów przy @-syntax:**

| Scenariusz | Złe podejście (dużo tokenów) | Dobre podejście (oszczędne) |
|------------|------------------------------|------------------------------|
| Duży plik | `@large-file.js` (10k linii) | `@large-file.js#L450-500` (konkretna funkcja) |
| Cały katalog | `@src/` (100 plików) | `@src/auth/` lub lista plików: `@src/auth.ts @src/jwt.ts` |
| Cały projekt | `@.` (disaster!) | Użyj CLAUDE.md z opisem architektury |
| Duplikaty | Wielokrotne referencje tego samego | Claude cache'uje - ale unikaj redundancji |

**Szacowanie kosztów tokenów:**

```bash
# Polecenie pomocnicze: sprawdź rozmiar przed dodaniem
> /tokens @large-file.js
# Output: ~15,000 tokens (może być za dużo!)

# Alternatywnie (manual check):
wc -l src/file.js  # 500 linii
# Reguła kciuka: ~4 znaki = 1 token
# 500 linii × 80 znaków/linia ÷ 4 = ~10,000 tokenów

# Dla całego katalogu:
find src/ -type f -name "*.js" -exec wc -l {} + | tail -1
# Zsumuj i podziel przez 4 dla grubego szacunku
```

**Workflow patterns z @-syntax:**

**Pattern 1: Incremental context building**
```bash
# Zamiast dużego bang na start:
> Przeanalizuj @src/ i zrefaktoruj wszystko  # ❌ Za dużo!

# Rób przyrostowo:
> Przeanalizuj strukturę @src/ (tylko lista plików)
> Ok, teraz szczegółowo @src/auth.ts
> Zrefaktoruj tę funkcję @src/auth.ts#L45-89
> Teraz zastosuj ten wzorzec w @src/api.ts
```

**Pattern 2: Reference chaining**
```bash
# Każda odpowiedź buduje kontekst:
> Co robi @src/config.js?
# Claude wyjaśnia
> Ok, teraz użyj tej konfiguracji w @src/app.js
# Claude wie już o config.js z poprzedniej odpowiedzi
> Przetestuj to w @tests/app.test.js
```

**Pattern 3: Scaffolding from examples**
```bash
# Użyj istniejącego kodu jako template:
> Stwórz @src/api/products.ts bazując na wzorcu z @src/api/users.ts
> Dodaj testy @tests/api/products.test.ts podobne do @tests/api/users.test.ts
```

#### **1.5. Pierwsze Spotkanie z Bezpieczeństwem (Wprowadzenie)**
*   **Zasada działania:** Claude domyślnie **pyta o zgodę** na każdą akcję, która może modyfikować system:
    *   **Read** – czytanie plików (bezpieczne)
    *   **Edit/Write** – modyfikacja/tworzenie plików (wymaga potwierdzenia)
    *   **Bash** – wykonywanie komend w terminalu (potencjalnie niebezpieczne!)
*   **Sandbox Mode:** Claude Code działa domyślnie w trybie sandbox, co oznacza **izolację do katalogu projektu**. Nie może automatycznie czytać `~/.ssh/`, `/etc/` ani innych wrażliwych lokacji bez wyraźnej zgody.
*   **Responses na pytania o uprawnienia:**
    *   `y` – tak, zezwól na tę operację
    *   `n` – nie, odrzuć
    *   `s` – pokaż szczegóły (co dokładnie ma być wykonane)
    *   `a` – zawsze zezwalaj (dla często używanych bezpiecznych operacji)
*   **To dopiero wierzchołek góry lodowej!** Pełny system uprawnień, konfiguracja sandbox, allow/deny lists, ochrona wrażliwych plików i best practices bezpieczeństwa będą szczegółowo omówione w **Module 2: Bezpieczeństwo i Uprawnienia**.

**Praktyczne przykłady systemu uprawnień (hands-on):**

**Scenariusz 1: Bezpieczne czytanie (Auto-approve)**
```bash
> Przeanalizuj @src/index.js

# Claude automatycznie czyta plik - brak pytania o zgodę
# ✅ Czytanie jest zawsze bezpieczne w sandboxie
```

**Scenariusz 2: Edycja pliku (Pierwsze pytanie o zgodę)**
```bash
> Dodaj error handling do @src/api.ts

# Claude Code pyta:
# ┌─ Permission Request ────────────────┐
# │ Edit file: src/api.ts               │
# │ Allow? (y/n/s/a)                    │
# └─────────────────────────────────────┘

# Opcje:
# y - Yes, tym razem
# n - No, odrzuć
# s - Show changes (pokaż co dokładnie będzie zmienione)
# a - Always (zawsze dla tego typu operacji w tym projekcie)
```

**Scenariusz 3: Wykonanie komendy bash (Highest risk)**
```bash
> Zainstaluj nowe dependencje i uruchom testy

# Claude Code pyta:
# ┌─ Permission Request ────────────────┐
# │ Execute: npm install                │
# │ Execute: npm test                   │
# │ Allow? (y/n/s)                      │
# └─────────────────────────────────────┘

# ⚠️ UWAGA: Bash commands mogą zmodyfikować system!
# Zawsze sprawdzaj 's' (show) przed zatwierdzeniem
```

**Pro-tipy dla bezpiecznej pracy:**

*   **Zawsze używaj 's' (show) przy pierwszym użyciu nowego typu operacji**
    ```bash
    # Claude chce edytować plik
    > s  # Pokaż co dokładnie

    # Output pokazuje dokładny diff:
    # --- old
    # +++ new
    # @@ -10,5 +10,8 @@
    # +  if (!data) throw new Error('Invalid data');

    # Teraz możesz świadomie wybrać y/n
    ```

*   **'Always allow' (a) tylko dla bezpiecznych, powtarzalnych operacji**
    ```bash
    # Dobre użycie 'a':
    # - Edycja plików w src/
    # - Czytanie package.json
    # - npm test (w sandboxie)

    # ZŁE użycie 'a':
    # - Instalacja globalnych package'ów (npm install -g)
    # - Modyfikacja plików systemowych
    # - Wykonywanie skryptów z internetu (curl | bash)
    ```

*   **Sprawdź aktywne uprawnienia:**
    ```bash
    > /permissions
    # Pokaże listę:
    # - Always allowed: Edit files in src/
    # - Denied: Read ~/.ssh/
    # - Pending: None
    ```

**Typowe pułapki bezpieczeństwa (dla początkujących):**

| Zagrożenie | Jak wygląda | Dlaczego niebezpieczne | Jak uniknąć |
|------------|-------------|------------------------|-------------|
| **Blind 'always allow'** | Kliknięcie 'a' bez sprawdzenia | Claude może przypadkowo nadpisać ważne pliki | Zawsze używaj 's' przed 'a' |
| **Wykroczenie poza sandbox** | `> Przeanalizuj ~/.ssh/id_rsa` | Dostęp do kluczy prywatnych | Nigdy nie dawaj dostępu do ~/.ssh, ~/.aws, etc. |
| **Destrukcyjne komendy** | `> Usuń wszystkie pliki tymczasowe` | Może usunąć za dużo | Sprawdź 's', ograncz scope: `> Usuń pliki w /tmp/project-temp/` |
| **Sekret w commit** | `> Commituj wszystko` | Możesz commitnąć .env z API keys | Zawsze sprawdzaj `git status` przed commit |
| **npm install bez audytu** | Auto-approve `npm install` | Może zainstalować malware | Przejrzyj package.json przed instalacją |

**Edge cases - co może pójść nie tak:**

*   **Claude próbuje czytać plik spoza projektu:**
    ```bash
    > Sprawdź konfigurację nginx
    # Claude próbuje: cat /etc/nginx/nginx.conf

    # ┌─ Sandbox Warning ───────────────────┐
    # │ Access denied: /etc/ is protected   │
    # │ Override? (y/n)                     │
    # └─────────────────────────────────────┘

    # ✅ Odpowiedź: n (chyba że naprawdę potrzebujesz)
    # Alternatywa: skopiuj plik do projektu:
    # sudo cp /etc/nginx/nginx.conf ./temp/
    # > Przeanalizuj @temp/nginx.conf
    ```

*   **Przypadkowe nadpisanie istniejącego pliku:**
    ```bash
    > Stwórz nowy component Button.tsx
    # Ale Button.tsx już istnieje!

    # ┌─ File exists warning ───────────────┐
    # │ Button.tsx already exists           │
    # │ Overwrite? (y/n/s)                  │
    # └─────────────────────────────────────┘

    # s - zobacz różnice między starym a nowym
    # n - anuluj, zachowaj stary plik
    # y - nadpisz (ostrożnie!)
    ```

*   **Masowe operacje na plikach:**
    ```bash
    > Zrefaktoruj wszystkie komponenty w src/
    # Claude chce edytować 50 plików

    # ⚠️ Nie klikaj 'a' dla wszystkich!
    # Lepiej:
    # 1. Przejrzyj plan: > Pokaż mi plan zmian (bez wykonywania)
    # 2. Testuj na jednym: > Zrefaktoruj tylko @src/Button.tsx
    # 3. Jak działa, rozszerz: > Ok, teraz resztę używając tego wzorca
    ```

**Troubleshooting - problemy z uprawnieniami:**

```bash
# Problem: "Permission denied" mimo zgody
# Rozwiązanie: Sprawdź ownership pliku
ls -la src/file.js
# Jeśli owner to root:
sudo chown $USER src/file.js

# Problem: Sandbox blokuje dostęp do node_modules
# Rozwiązanie: node_modules jest w .claudeignore
# Usuń z .claudeignore jeśli potrzebujesz dostępu

# Problem: Nie pamiętam co zaznaczyłem jako 'always allow'
# Rozwiązanie:
> /permissions list
# Lub sprawdź plik:
cat ~/.claude/permissions.json

# Problem: Chcę zresetować wszystkie uprawnienia
# Rozwiązanie:
> /permissions reset
# Lub ręcznie:
rm ~/.claude/permissions.json
```

**Bezpieczne wzorce pracy (Quick Reference):**

**✅ DOBRE praktyki:**
```bash
# 1. Zawsze sprawdzaj przed wykonaniem
> s (show) przed y (yes)

# 2. Ogranicz scope operacji
> Usuń pliki *.log w /tmp/myproject/  # Precyzyjne
❌ > Wyczyść dysk  # Za ogólne!

# 3. Używaj git jako safety net
git commit -am "Before Claude refactoring"
> Zrefaktoruj kod
# Jeśli coś pójdzie nie tak:
git reset --hard HEAD

# 4. Suche uruchomienia (dry-run)
> Pokaż mi co byś zrobił, ale nie wykonuj  # Simulation mode
> Ok, teraz wykonaj to  # Actual execution

# 5. Backupy przed dużymi zmianami
cp -r src/ src.backup/
> Przeprowadź dużą migrację w src/
# Restore jeśli problem:
rm -rf src/ && mv src.backup/ src/
```

**❌ ZŁE praktyki (unikaj!):**
```bash
# 1. Blind trust
> a (always) dla wszystkiego  # Nigdy!

# 2. Root access
sudo claude  # Bardzo niebezpieczne!

# 3. Produkcyjne operacje bez weryfikacji
> Zaktualizuj bazę produkcyjną  # Sprawdź środowisko!

# 4. Sekretne dane w promptach
> Połącz się z DB: password=SuperSecret123  # Wyciek do historii!
# Lepiej: użyj zmiennych środowiskowych

# 5. Wykonywanie nieznanego kodu
> Pobierz i uruchom skrypt z https://sketchy-site.com/install.sh
# Claude może to zrobić - ale NIE POZWALAJ!
```

**Quick Security Checklist przed startem:**

```markdown
☐ Sprawdziłem że jestem w właściwym katalogu (`pwd`)
☐ .gitignore zawiera .env, *.key, secrets/
☐ ~/.claude/permissions.json nie ma 'always allow' dla /
☐ Pracuję na branchu, nie na main (`git branch`)
☐ Mam backup ważnych plików (git commit lub cp)
☐ Sandbox mode jest włączony (domyślnie - sprawdź /settings)
☐ Nie używam sudo z Claude Code
☐ API keys są w .env, nie w kodzie
```

**Następny krok:** Moduł 2 szczegółowo omówi:
- Konfigurację zaawansowanych sandboxów
- Allow/deny lists dla plików i komend
- Ochronę secrets i sensitive data
- Audit logs i monitoring
- Best practices dla pracy w zespole

#### **1.6. Pamięć Projektu: `CLAUDE.md` i Hierarchia Kontekstu**
*   **Hierarchia plików:**
    *   `~/.claude/CLAUDE.md`: Globalne preferencje użytkownika (np. "Zawsze używaj TypeScript", "Nie używaj emoji w commitach").
    *   `./CLAUDE.md`: Instrukcje specyficzne dla projektu (architektura, komendy budowania).
    *   `./CLAUDE.local.md`: Prywatne notatki ignorowane przez Gita (np. lokalne ścieżki, klucze testowe).
    *   `./.claude/rules/*.md`: Modularyzacja reguł w osobne pliki (zaawansowane).
*   **Komenda `/init`:** Automatyczne generowanie szkieletu `CLAUDE.md` na podstawie analizy repozytorium.
*   **Komenda `/memory`:** Edycja plików CLAUDE.md bezpośrednio z REPL - wygodny sposób na aktualizację instrukcji projektu.
*   **Import plików:** Użyj składni `@ścieżka/do/pliku` w CLAUDE.md aby zaimportować zawartość innych plików do kontekstu (np. `@README.md` lub `@docs/architecture.md`).
*   **Dobra praktyka:** Traktuj `CLAUDE.md` jak dokument onboardingowy dla nowego junior developera – musi zawierać komendy build/test i strukturę folderów.

**Praktyczne przykłady CLAUDE.md (od podstaw do eksperta):**

**Level 1: Minimalny CLAUDE.md (quick start)**
```markdown
# My Project

## Setup
- npm install
- npm run dev (starts on :3000)
- npm test

## Structure
- src/ - aplikacja
- tests/ - testy
- docs/ - dokumentacja
```

**Level 2: Rozbudowany (production-ready)**
````markdown
# E-Commerce Platform

## Tech Stack
- **Frontend:** React 18 + TypeScript + Vite
- **Backend:** Node.js + Express + PostgreSQL
- **Testing:** Jest + React Testing Library + Playwright
- **Deployment:** Vercel (frontend) + Railway (backend)

## Development
```bash
# Setup
npm install
cp .env.example .env  # Wypełnij DATABSE_URL

# Development
npm run dev          # Start dev server (:3000)
npm run dev:backend  # Start API (:8080)
npm test             # Unit tests
npm run test:e2e     # E2E tests (wymaga running server)

# Building
npm run build        # Production build
npm run preview      # Preview production build
```

## Architecture
```
src/
├── components/    # Reusable React components
│   ├── ui/       # Shadcn/ui components
│   └── features/ # Feature-specific components
├── pages/        # Next.js-style pages
├── hooks/        # Custom React hooks
├── services/     # API calls and external services
├── utils/        # Utility functions
└── types/        # TypeScript type definitions
```

## Coding Standards
- **Imports:** Use absolute imports (@/components vs ../components)
- **Components:** Always functional, use hooks, no class components
- **Styling:** Tailwind CSS, avoid inline styles
- **State:** Zustand for global, useState for local
- **Error handling:** Always use try/catch, return meaningful errors
- **Commit messages:** Conventional Commits (feat:, fix:, docs:, etc.)

## Database
- **ORM:** Prisma
- **Migrations:** `npm run db:migrate`
- **Reset DB:** `npm run db:reset` (dev only!)
- **Seed:** `npm run db:seed`

## Common Tasks
- **Add new component:** Use template in `scripts/new-component.sh`
- **Add new API endpoint:** Follow pattern in `src/api/users.ts`
- **Update dependencies:** `npm run update-deps` (runs audit + update)

## Testing
- Coverage minimum: 80%
- Always test: API endpoints, custom hooks, utils
- E2E: Critical user flows only (auth, checkout)

## Deployment
- **Staging:** Auto-deploy on push to `develop`
- **Production:** Manual deploy from `main` (needs approval)
- **Rollback:** `git revert` + push (auto-deploys)

## Troubleshooting
- **Port 3000 in use:** `lsof -ti:3000 | xargs kill -9`
- **DB connection failed:** Check DATABASE_URL in .env
- **Tests failing:** Clear cache `npm run test:clear-cache`
````

**Level 3: Expert (multi-environment, team scale)**
````markdown
# Enterprise SaaS Platform

## Quick Links
- [API Docs](https://api.company.com/docs)
- [Figma](https://figma.com/file/...)
- [Confluence](https://company.atlassian.net/...)
- [Jira Board](https://company.atlassian.net/jira/...)

## Tech Stack & Versions (as of 2024-12)
- **Frontend:** Next.js 14 (App Router) + TypeScript 5.3 + React 18.2
- **Backend:** NestJS 10 + GraphQL + TypeORM
- **Database:** PostgreSQL 15 (primary) + Redis 7 (cache) + Elasticsearch 8 (search)
- **Auth:** Auth0 (production) + Mock auth (development)
- **Payments:** Stripe API v2023-10-16
- **Testing:** Jest 29 + Playwright 1.40 + Storybook 7
- **Infra:** Kubernetes + Terraform + ArgoCD

## Environment Setup

### Prerequisites
```bash
- Node 20.x (use nvm: `nvm use`)
- Docker Desktop 4.x (for local DB)
- kubectl & helm (for K8s debugging)
- AWS CLI v2 (for S3 access)
```

### First Time Setup
```bash
# 1. Install dependencies
npm install

# 2. Setup local environment
cp .env.example .env.local
./scripts/setup-dev.sh  # Interactive wizard

# 3. Start infrastructure
docker-compose up -d  # DB, Redis, Elasticsearch

# 4. Run migrations & seed
npm run db:migrate
npm run db:seed -- --env=dev

# 5. Verify setup
npm run doctor  # Checks all dependencies
```

### Daily Development
```bash
# Start all services
npm run dev:all  # Frontend (:3000) + Backend (:8080) + Storybook (:6006)

# Or individually:
npm run dev           # Frontend only
npm run dev:backend   # Backend only
npm run dev:docs      # Storybook
```

## Architecture Decisions (ADRs)

### State Management
- **Global state:** Zustand (NOT Redux - deprecated 2024-01)
- **Server state:** React Query v5 (TanStack Query)
- **Form state:** React Hook Form + Zod validation
- **URL state:** Next.js searchParams (no query-string lib)

### API Patterns
- **REST vs GraphQL:**
  - Public API: REST (versioned: /api/v1/)
  - Internal: GraphQL (single endpoint: /graphql)
- **Pagination:** Cursor-based (NOT offset/limit)
- **Error format:** RFC 7807 Problem Details

### Styling
- **CSS Framework:** Tailwind CSS 3 (config: tailwind.config.ts)
- **Component Library:** Custom (based on shadcn/ui)
- **Icons:** Lucide React (NOT FontAwesome - deprecated)
- **Fonts:** Inter (variable) loaded via next/font

### Testing Strategy
```
                    │ Unit │ Integration │ E2E │
────────────────────┼──────┼─────────────┼─────┤
Coverage Target     │ 90%  │ 70%         │ 30% │
Test Location       │ *.test.ts         │ e2e/│
Mock External APIs  │ Yes  │ Yes         │ No  │
Run on Pre-commit   │ Yes  │ No          │ No  │
Run on PR           │ Yes  │ Yes         │ Yes │
```

## File Structure (Critical Paths)

```
apps/
├── web/              # Next.js frontend
│   ├── app/          # App router pages
│   ├── components/   # React components
│   └── lib/          # Frontend utilities
├── api/              # NestJS backend
│   ├── src/
│   │   ├── modules/  # Feature modules
│   │   ├── common/   # Shared code
│   │   └── config/   # Configuration
└── mobile/           # React Native (future)

packages/
├── ui/               # Shared component library
├── types/            # Shared TypeScript types
├── utils/            # Shared utilities
└── eslint-config/    # Shared ESLint config

infrastructure/
├── terraform/        # IaC for AWS
├── kubernetes/       # K8s manifests
└── docker/           # Dockerfiles
```

## Development Workflows

### Adding a New Feature
1. Create feature branch: `git checkout -b feature/JIRA-123-description`
2. Update ADR if architecture decision: `docs/adr/NNNN-decision.md`
3. Implement following TDD: test -> code -> refactor
4. Add Storybook story for UI components
5. Update API docs (OpenAPI/GraphQL schema)
6. Create PR with template (auto-filled)
7. Wait for CI (tests, lint, build, security scan)
8. Get 2 approvals (1 must be tech lead)
9. Squash & merge (auto-deploys to staging)

### Database Migrations
```bash
# Create migration
npm run db:migration:create -- --name=add_user_roles

# Edit migration in: prisma/migrations/XXX_add_user_roles/migration.sql

# Test migration (up & down)
npm run db:migrate -- --env=test
npm run db:migrate:rollback -- --env=test

# Apply to dev DB
npm run db:migrate

# Production (via CI/CD only!)
# Never run manually in prod!
```

### Debugging

**Backend API**
```bash
# Debug mode with inspector
npm run dev:backend:debug  # Starts on :9229

# In VS Code: Attach to Process (F5)
# Or Chrome: chrome://inspect
```

**Database queries**
```bash
# Enable query logging
export DEBUG="prisma:query"
npm run dev

# or use Prisma Studio
npm run db:studio  # Opens GUI on :5555
```

**Frontend**
```bash
# React DevTools in browser (Chrome extension)
# or Next.js built-in:
# Click Next.js icon in bottom right corner
```

## Team Conventions

### Branch Naming
- `feature/JIRA-123-short-description`
- `bugfix/JIRA-456-short-description`
- `hotfix/critical-issue-description`
- `chore/update-dependencies`

### Commit Messages (Conventional Commits)
```
feat(auth): add OAuth2 support for Google
fix(api): handle null values in user profile
docs(readme): update setup instructions
chore(deps): upgrade Next.js to 14.1
test(users): add integration tests for CRUD
refactor(payments): extract Stripe logic to service
perf(db): add index on user_id for faster lookups
```

### Code Review Checklist
- [ ] Tests pass locally and on CI
- [ ] Code follows style guide (checked by lint)
- [ ] No console.log or debugger statements
- [ ] Error handling is comprehensive
- [ ] Security: no hardcoded secrets, sanitized inputs
- [ ] Performance: no N+1 queries, optimized images
- [ ] Accessibility: ARIA labels, keyboard navigation
- [ ] Documentation: JSDoc for complex functions

## Common Issues & Solutions

### "Module not found" after git pull
```bash
# Stale node_modules
rm -rf node_modules package-lock.json
npm install
```

### "Database schema out of sync"
```bash
# Reset database (DEV ONLY!)
npm run db:reset
npm run db:seed
```

### "Port already in use"
```bash
# Find and kill process
lsof -ti:3000 | xargs kill -9  # Frontend
lsof -ti:8080 | xargs kill -9  # Backend
```

### "Docker containers won't start"
```bash
# Nuclear option: remove all containers
docker-compose down -v
docker system prune -a
docker-compose up -d
```

### "Tests fail on CI but pass locally"
```bash
# Likely timezone or env var issue
# Run tests with CI environment:
CI=true npm test
```

## Security Best Practices

- **Secrets:** NEVER commit to git. Use .env.local (gitignored)
- **API Keys:** Rotate every 90 days (Notion reminder)
- **Dependencies:** Run `npm audit` weekly, fix HIGH/CRITICAL immediately
- **Auth tokens:** Expire after 1h (refresh token pattern)
- **CORS:** Whitelist domains in api/src/config/cors.ts
- **Rate limiting:** Enabled by default (100 req/min per IP)

## Performance Targets

- **Lighthouse Score:** >90 on all metrics (mobile + desktop)
- **Time to Interactive (TTI):** <3s on 3G
- **Largest Contentful Paint (LCP):** <2.5s
- **Cumulative Layout Shift (CLS):** <0.1
- **First Input Delay (FID):** <100ms
- **API Response Time:** p95 < 500ms

## Monitoring & Alerts

- **Error tracking:** Sentry (auto-reports exceptions)
- **Metrics:** Datadog (dashboards: https://app.datadoghq.com/...)
- **Logs:** CloudWatch (query: `kubectl logs -f deployment/api`)
- **Uptime:** Pingdom (alerts via PagerDuty)
- **On-call rotation:** See PagerDuty schedule

## Useful Commands

```bash
# Find todos in codebase
npm run find:todos  # Grep for // TODO:, FIXME:, etc.

# Generate TypeScript types from GraphQL schema
npm run codegen

# Analyze bundle size
npm run build
npm run analyze  # Opens visualization

# Update all dependencies (interactive)
npx npm-check-updates -ui

# Run security audit
npm audit --production
npm run audit:licenses  # Check license compliance
```

## Resources

- **Onboarding Doc:** [Notion](https://notion.so/...)
- **API Playground:** [GraphiQL](http://localhost:8080/graphql)
- **Component Library:** [Storybook](http://localhost:6006)
- **Deployment Logs:** [Vercel](https://vercel.com/...)
- **Slack Channels:**
  - `#eng-team` - General engineering
  - `#deploys` - Deployment notifications
  - `#incidents` - Production incidents
````

**Pro-tipy dla CLAUDE.md:**

*   **Automatyczna generacja startowa:**
    ```bash
    # W katalogu projektu:
    claude

    > /init
    # Claude analizuje projekt i generuje CLAUDE.md

    # Edytuj wygenerowany plik:
    > Otwórz @CLAUDE.md i dodaj sekcję "Common Mistakes"
    ```

*   **Szybkie dodawanie do pamięci:**
    ```bash
    # W trakcie rozmowy użyj /memory do edycji CLAUDE.md:
    > /memory
    # Otworzy edytor z CLAUDE.md gdzie możesz dodać nowe reguły

    # Lub bezpośrednio edytuj plik:
    > Edit @CLAUDE.md i dodaj regułę: "Always use camelCase for variable names"
    ```

*   **Hierarchia ładowania kontekstu (od najwyższego priorytetu):**
    ```
    1. Enterprise policy (ustawienia na poziomie organizacji)
       ↓
    2. Project memory (./CLAUDE.md lub ./.claude/CLAUDE.md)
       ↓
    3. Project rules (./.claude/rules/*.md - modularyzacja)
       ↓
    4. User memory (~/.claude/CLAUDE.md - globalne preferencje)
       ↓
    5. Project memory local (./CLAUDE.local.md - gitignored)
    ```

*   **Template dla nowego projektu:**
    ```bash
    # Skopiuj template z innego projektu:
    cp ~/Projects/reference-project/CLAUDE.md ./

    # Lub stwórz własny template:
    mkdir -p ~/.claude/templates
    # Edit ~/.claude/templates/webapp.md
    # Potem:
    cp ~/.claude/templates/webapp.md ./CLAUDE.md
    ```

*   **Modularyzacja reguł z `.claude/rules/` (ZAAWANSOWANE):**
    ```bash
    # Zamiast jednego dużego CLAUDE.md, podziel na moduły:
    .claude/
    ├── CLAUDE.md (główny plik)
    └── rules/
        ├── coding-style.md
        ├── testing.md
        ├── deployment.md
        └── security.md
    ```

    **Przykład pliku `.claude/rules/coding-style.md`:**
    ```markdown
    # Coding Style Rules

    - Always use TypeScript strict mode
    - Prefer functional components over class components
    - Use camelCase for variables, PascalCase for components
    - Maximum line length: 100 characters
    ```

    **Zaawansowane: Path-specific rules z YAML frontmatter:**
    ```markdown
    ---
    paths:
      - "src/**/*.test.ts"
      - "tests/**/*"
    ---

    # Testing Rules
    - Always test edge cases
    - Minimum 80% coverage
    - Use descriptive test names
    ```

    Ta reguła będzie aktywna tylko gdy pracujesz z plikami testowymi!

*   **Import innych plików do kontekstu (`@syntax`):**
    ```markdown
    # W CLAUDE.md możesz zaimportować inne pliki:

    ## Project Overview
    See @README.md for general information

    ## Available Commands
    See @package.json for npm scripts

    ## Architecture
    See @docs/architecture.md for system design

    ## API Documentation
    See @docs/api-spec.yaml
    ```

    Claude automatycznie załaduje zawartość tych plików do kontekstu!

    **Przykłady importów:**
    - `@README.md` - import z bieżącego katalogu
    - `@docs/setup.md` - import z podkatalogu
    - `@~/.claude/global-rules.md` - import z katalogu domowego

**Typowe błędy i rozwiązania:**

| Problem | Objaw | Rozwiązanie |
|---------|-------|-------------|
| **Claude ignoruje CLAUDE.md** | Nie stosuje się do reguł | Sprawdź czy plik jest w root projektu i poprawnie sformatowany (Markdown) |
| **Za długi CLAUDE.md** | Zużywa za dużo tokenów | Ogranicz do <500 linii. Przenieś szczegóły do osobnych docs/ |
| **Konflikt między global a project** | Niespójne zachowanie | Project CLAUDE.md ma priorytet nad global |
| **CLAUDE.local.md w repo** | Przypadkowy commit | Dodaj do .gitignore: `echo "CLAUDE.local.md" >> .gitignore` |
| **Stare informacje w pamięci** | Claude używa outdated data | Zaktualizuj CLAUDE.md i uruchom `/reload` |

**Edge cases:**

*   **Multi-projekt (monorepo):**
    ```
    root/
    ├── CLAUDE.md (globalne dla monorepo)
    ├── packages/
    │   ├── web/
    │   │   └── CLAUDE.md (specific dla web app)
    │   └── api/
    │       └── CLAUDE.md (specific dla API)
    ```
    Claude ładuje oba (root + subdirectory) jeśli uruchomiony w subdirectory.

*   **Wrażliwe dane (nigdy w CLAUDE.md!):**
    ```markdown
    ❌ BAD:
    ## Database
    - Connection: postgres://user:password123@prod.db.com

    ✅ GOOD:
    ## Database
    - Connection: See DATABASE_URL in .env.local
    - Schema: Run `npm run db:schema` to see latest
    ```

*   **Dynamiczne dane (wersje, daty):**
    ```markdown
    ## Tech Stack (as of 2024-12)
    - Next.js 14 (check package.json for current version)
    - Run `npm list next` for exact version
    ```

**Cheat sheet - co powinno być w CLAUDE.md:**

```markdown
✅ Obowiązkowe:
- Setup commands (install, start, test)
- Tech stack (języki, framework'i, major libraries)
- Struktura projektu (główne katalogi)
- Development workflow (jak dodać feature)

✅ Zalecane:
- Coding standards (style guide, conventions)
- Common tasks (częste operacje)
- Troubleshooting (znane problemy + rozwiązania)
- Team conventions (jeśli praca zespołowa)

✅ Opcjonalne (advanced):
- Architecture decisions (ADRs)
- Performance targets
- Security guidelines
- Deployment process

❌ Unikaj:
- Sekretów (hasła, API keys)
- Bardzo szczegółowych implementacji (to powinno być w docs/)
- Duplikatów tego co jest w README (link zamiast kopiować)
```

#### **1.7. Podstawowe Narzędzia i Komendy (Slash Commands)**
*   **Zarządzanie kontekstem (Klucz do oszczędności):**
    *   `/clear`: Czyści historię, resetuje kontekst (tani restart).
    *   `/compact`: Podsumowuje rozmowę, zwalnia miejsce w oknie kontekstowym, ale zachowuje kluczowe ustalenia,.
    *   **Strategia:** "Checkpoint Pattern" – pracuj 30-60 min, zrób `/compact` (lub zapisz podsumowanie do pliku), a potem `/clear`.
*   **Monitorowanie:** `/cost` i `/usage` – sprawdzanie ile kosztowała dana sesja i ile tokenów pozostało,.
*   **Inne przydatne:** `/help` (pomoc), `/version` (sprawdzenie wersji).

**Kompletna lista slash commands:**

| Komenda | Funkcja | Przykład użycia |
|---------|---------|-----------------|
| `/help` | Pokaż dostępne komendy | `/help` |
| `/clear` | Wyczyść historię i kontekst | `/clear` (przed startem nowego zadania) |
| `/compact` | Skompresuj historię, zachowaj kluczowe info | `/compact` (po 30-60 min pracy) |
| `/cost` | Pokaż koszt obecnej sesji | `/cost` (sprawdź ile wydałeś) |
| `/usage` | Pokaż zużycie tokenów | `/usage` |
| `/login` | Zaloguj się do konta Claude | `/login` |
| `/logout` | Wyloguj się | `/logout` |
| `/settings` | Pokaż aktualną konfigurację | `/settings` |
| `/init` | Wygeneruj CLAUDE.md dla projektu | `/init` (w root projektu) |
| `/memory` | Edytuj pliki CLAUDE.md | `/memory` (otwórz edytor pamięci projektu) |
| `/doctor` | Diagnostyka instalacji i połączenia | `/doctor` (troubleshooting) |
| `/permissions` | Zarządzaj uprawnieniami | `/permissions` (pokaż/edytuj uprawnienia) |
| `/export` | Eksportuj konwersację do pliku | `/export conversation.md` |
| `/version` | Sprawdź wersję Claude Code | `/version` |

**Praktyczne przykłady:**

```bash
# Scenario 1: Długa sesja kodowania (zarządzanie kontekstem)
> Dodaj autentykację OAuth do projektu
[... 30 minut pracy, wiele plików edytowanych ...]

> /usage
# Output: Using 45,000 / 200,000 tokens (22%)

> /compact
# Claude: "Podsumowałem dotychczasową pracę. Zaimplementowaliśmy OAuth z Google i GitHub,
#          dodaliśmy endpointy /auth/login i /auth/callback, oraz testy..."

> /usage
# Output: Using 8,000 / 200,000 tokens (4%) # Oszczędność 37k tokenów!

# Kontynuuj pracę z czystszym kontekstem
> Teraz dodaj obsługę sesji z Redis
```

```bash
# Scenario 2: Przełączanie między projektami
> /export project-a-progress.md  # Zapisz postęp
> /clear  # Wyczyść kontekst

# Przejdź do innego projektu
cd ~/Projects/project-b
claude

> /init  # Załaduj kontekst project-b
> Kontynuuj pracę nad feature X
```

```bash
# Scenario 3: Monitorowanie kosztów
> /cost
# Session started: 14:23:15
# Duration: 1h 23m
# Total cost: $0.87
# Model: claude-sonnet-4.5
# Input tokens: 125,443
# Output tokens: 38,291

# Jeśli za drogo:
> /compact  # Zmniejsz zużycie
# lub przełącz na tańszy model (Haiku)
```

**Pro-tipy dla slash commands:**

*   **Checkpoint pattern (oszczędzanie $$$):**
    ```bash
    # Co 30-60 minut:
    > /cost              # Sprawdź ile wydałeś
    > /compact           # Skompresuj jeśli >50k tokens
    > /export backup.md  # Backup progress

    # Przed końcem sesji:
    > /export final-summary.md
    > /clear
    ```

*   **Workflow dla zespołów (handoff):**
    ```bash
    # Developer A kończy pracę:
    > /export handoff-to-bob.md
    > Podsumuj co zrobiono i co pozostało do zrobienia

    # Developer B przejmuje:
    > Przeczytaj @handoff-to-bob.md i kontynuuj
    ```

*   **Debug workflow:**
    ```bash
    > /doctor  # Pierwsza linia obrony przy problemach

    # Jeśli problem z kosztami:
    > /cost
    > /usage

    # Jeśli problem z uprawnieniami:
    > /permissions list
    > /permissions reset  # Nuclear option

    # Jeśli problem z konfiguracją:
    > /settings
    ```

**Typowe błędy:**

| Błąd | Objaw | Rozwiązanie |
|------|-------|-------------|
| **Zapomnienie /compact** | Session cost > $5 | Regularnie kompaktuj co 30-60 min |
| **Użycie /clear zamiast /compact** | Utrata całego kontekstu | Używaj `/export` przed `/clear` |
| **Nie sprawdzanie /cost** | Nieoczekiwanie wysoki rachunek | Ustaw habit: `/cost` co godzinę |
| **Brak /export** | Utrata postępu przy crashu | `/export` przed każdą dużą zmianą |

**Advanced tricks:**

```bash
# Auto-export przy wyjściu (dodaj do ~/.zshrc)
claude-session() {
    claude
    # Po wyjściu z Claude (Ctrl+D):
    echo "Saving session..."
    claude /export "session-$(date +%Y%m%d-%H%M).md"
}

# Alias do quick diagnostics
alias cdoc='claude /doctor && claude /usage && claude /cost'

# Periodic cost alerts (w tle podczas pracy)
watch -n 300 'claude /cost'  # Co 5 min sprawdź koszt
```

#### **1.8. Tryby Pracy (Shift+Tab) i Rozszerzone Myślenie**
*   **Przełączanie trybów:** Użycie `Shift+Tab` do cyklicznego przełączania: Ask -> Auto-Edit -> Plan Mode.
*   **Plan Mode (Tryb Planowania):**
    *   Claude nie pisze kodu, lecz tworzy plan działania. Idealne do złożonych zadań, aby uniknąć "halucynowania" rozwiązań.
    *   *Tip:* Używaj tego trybu do eksploracji ("Zbadaj strukturę projektu i zaproponuj plan migracji").
*   **Thinking Mode (`ultrathink`):**
    *   Jak wymusić głębsze rozumowanie za pomocą słowa kluczowego `ultrathink` (uwaga: słowa `think hard` mogą już nie działać w nowszych wersjach),.
    *   Kiedy używać: Architektura, debugowanie trudnych błędów, analiza bezpieczeństwa.

**Szczegółowy przegląd trybów pracy:**

| Tryb | Kiedy używać | Co robi Claude | Przykład |
|------|--------------|----------------|----------|
| **Ask Mode** | Pytania, eksploracja, learning | Odpowiada bez modyfikacji plików | "Wyjaśnij jak działa @src/auth.ts" |
| **Auto-Edit Mode** | Standardowa praca dev | Automatycznie edytuje pliki | "Dodaj error handling do API" |
| **Plan Mode** | Złożone zadania, architektura | Tworzy plan bez wykonywania | "Zaplanuj migrację z REST na GraphQL" |

**Praktyczne przykłady:**

```bash
# Ask Mode (domyślny przy starcie)
> Jak zrefaktorować ten kod @src/utils/parser.js?
# Claude: "Oto 3 sugestie: 1) Extract function, 2) Use regex, 3) Add caching..."
# Pliki NIE są modyfikowane

# Przełącz na Auto-Edit Mode
<Shift+Tab>  # Przełącz tryb

> Zrefaktoruj @src/utils/parser.js używając sugestii #2
# Claude automatycznie edytuje plik
# Pokazuje diff
# Pyta o approval (y/n/s)

# Przełącz na Plan Mode
<Shift+Tab>  # Przełącz tryb ponownie

> Przeprowadź pełną migrację do TypeScript
# Claude: "Plan migracji w 5 krokach:
# 1. Install TypeScript dependencies
# 2. Create tsconfig.json
# 3. Rename .js files to .ts
# 4. Fix type errors
# 5. Update build scripts
# Estimated time: 3-4 hours
# Should I proceed with step 1?"
# Możesz teraz zaakceptować plan lub go zmodyfikować
```

**Pro-tipy dla trybów:**

*   **Plan Mode dla nowych projektów:**
    ```bash
    <Shift+Tab>  # Przełącz na Plan Mode
    > Stwórz nowy projekt React z Next.js, TypeScript, Tailwind i Prisma

    # Claude tworzy szczegółowy plan:
    # ✓ Folder structure
    # ✓ Dependencies to install
    # ✓ Configuration files needed
    # ✓ Step-by-step implementation

    > Ok, wykonaj krok 1-3
    # Teraz wykonuje tylko te kroki
    ```

*   **Thinking Mode dla trudnych problemów:**
    ```bash
    > <thinking>
    > Dlaczego ten kod powoduje memory leak?
    > @src/components/DataGrid.tsx
    > </thinking>

    # Claude używa rozszerzonego reasoning:
    # - Analizuje lifecycle
    # - Sprawdza event listeners
    # - Bada closures i references
    # - Pokazuje szczegółowe wnioski

    # Alternatywnie:
    > Analyze this memory leak (think deeply):
    > @src/components/DataGrid.tsx
    ```

*   **Combo: Plan + Auto-Edit workflow:**
    ```bash
    # 1. Zaplanuj (Plan Mode)
    <Shift+Tab>
    > Zaplanuj refaktoryzację architektury komponentów

    # 2. Review planu
    > Pokaż więcej szczegółów dla kroku 3

    # 3. Wykonaj (Auto-Edit Mode)
    <Shift+Tab>
    > Wykonaj kroki 1-3 z planu

    # 4. Weryfikuj (Ask Mode)
    <Shift+Tab>
    > Czy refaktoryzacja zachowała wszystkie funkcjonalności?
    ```

**Typowe błędy:**

| Błąd | Objaw | Rozwiązanie |
|------|-------|-------------|
| **Używanie Auto-Edit dla eksploracji** | Claude modyfikuje pliki niepotrzebnie | Użyj Ask Mode do pytań |
| **Brak planu dla dużych zmian** | Chaotyczna implementacja | Zacznij od Plan Mode |
| **Nie sprawdzenie trybu** | Nieoczekiwane zachowanie | Sprawdź aktywny tryb (wyświetlany na dole) |
| **Za szybkie akceptowanie w Auto-Edit** | Wprowadzenie błędów | Zawsze używaj 's' (show) przed 'y' |

**Advanced: Extended Thinking**

```bash
# Dla najtrudniejszych problemów:
> Think step-by-step about this architecture:
> @docs/system-design.md
> Consider scalability, security, and maintainability

# Claude używa "chain of thought":
# Step 1: Analyzing current architecture...
# Step 2: Identifying bottlenecks...
# Step 3: Evaluating alternatives...
# Step 4: Security implications...
# Step 5: Final recommendation...

# Keyword triggers dla deep thinking:
- "think step-by-step"
- "analyze deeply"
- "consider all edge cases"
- "evaluate pros and cons"
- "what could go wrong?"
```

**Edge case: Mieszane tryby w jednej sesji**

```bash
# Możesz łączyć tryby dla optymalnego workflow:

# 1. ASK: Zrozumienie problemu
> Jak działa obecny system autentykacji? @src/auth/

# 2. PLAN: Strategia zmian
<Shift+Tab>
> Zaplanuj dodanie 2FA

# 3. ASK: Clarification
<Shift+Tab>
> Które metody 2FA są najbezpieczniejsze?

# 4. AUTO-EDIT: Implementacja
<Shift+Tab>
> Zaimplementuj TOTP-based 2FA według planu

# 5. ASK: Verification
<Shift+Tab>
> Przejrzyj kod pod kątem bezpieczeństwa
```

#### **1.9. "Supermoce" na start (Ciekawe pomysły)**
*   **Voice Coding:** Użycie narzędzi typu SuperWhisper do dyktowania promptów – działa szybciej niż pisanie i Claude świetnie radzi sobie z transkrypcją mowy potocznej.
*   **Obsługa obrazów:** Wklejanie zrzutów ekranu (UI, błędy) bezpośrednio do terminala (`Ctrl+V` lub drag&drop) – Claude widzi co się dzieje,.
*   **Praca z dokumentacją:** Wklejanie linków do dokumentacji lub całych plików PDF, aby Claude nauczył się nowych bibliotek w locie.

**Praktyczne przykłady "supermocnych" feature'ów:**

**1. Voice Coding (hands-free development)**

```bash
# Setup: Zainstaluj SuperWhisper (macOS) lub Whisper CLI (Linux/Windows)

# Workflow:
# 1. Naciśnij hotkey (np. Cmd+Shift+Space)
# 2. Powiedz: "Dodaj walidację email do formularza rejestracji"
# 3. SuperWhisper transkrybuje i wysyła do Claude
# 4. Claude implementuje

# Pro-tip: Mów naturalnie, Claude rozumie context:
"Hej, ta funkcja w pliku auth jest za długa, rozbij ją na mniejsze kawałki"
# Claude zrozumie i wykona
```

**2. Visual Debugging (screenshots + errors)**

```bash
# Scenario 1: UI bug
# 1. Zrób screenshot (Cmd+Shift+4 na macOS)
# 2. Drag & drop do terminala Claude
> @screenshot.png - ten button jest źle wyrównany, napraw CSS

# Scenario 2: Console error
> @error-console.png - co oznacza ten błąd i jak go naprawić?
# Claude: "To jest CORS error. Dodaj header Access-Control-Allow-Origin..."

# Scenario 3: Design implementation
> @figma-mockup.png - zaimplementuj ten layout używając Tailwind
```

**3. PDF Documentation Learning**

```bash
# Dodaj dokumentację biblioteki:
> @stripe-api-docs.pdf - naucz się Stripe API

# Potem użyj wiedzy:
> Zaimplementuj payment flow używając Stripe
# Claude używa informacji z PDF

# Advanced: Multiple PDFs
> Przeczytaj @aws-s3-docs.pdf i @cloudfront-docs.pdf
> Zaimplementuj CDN setup dla naszych statycznych assetów
```

**4. Clipboard Integration (power workflow)**

```bash
# macOS/Linux setup:
alias cpclip='pbcopy'  # macOS
alias cpclip='xclip -selection clipboard'  # Linux

# Workflow:
# 1. Skopiuj error z przeglądarki (Cmd+C)
# 2. W Claude:
> Przeanalizuj ten error: $(pbpaste)

# Reverse: Kopiuj output Claude
> Wygeneruj 10 przykładowych email addressów | pbcopy
```

**5. Git Workflow Automation**

```bash
# Automatyzacja całego git flow:
> Przejrzyj moje uncommitted changes, stwórz sensowny commit message i zrób commit

# Advanced: PR creation
> Stwórz branch feature/add-oauth, commit changes i push, potem stwórz PR
# Claude robi wszystko automatycznie!
```

**6. Testing Superpowers**

```bash
# Auto-generate tests:
> Wygeneruj testy jednostkowe dla @src/auth.ts z 100% coverage

# Visual regression:
> @screenshot-before.png @screenshot-after.png - porównaj visual regressions

# E2E test from user flow:
> Wygeneruj Playwright test dla tego flow:
> 1. User opens /login
> 2. Enters credentials
> 3. Should redirect to /dashboard
```

**Pro-tipy:**

*   **Combo: Voice + Visual** - Mów podczas pokazywania screenshotów
*   **Bulk Operations** - Masowe zmiany z pattern matching
*   **Cross-project Learning** - Transfer wiedzy między projektami
*   **Documentation Generation** - Auto-generuj README, JSDoc, OpenAPI specs
*   **Security Audit** - Znajdź SQL injection, XSS, unsafe dependencies

**Kluczowe wnioski:**

- Claude Code to nie tylko text-based tool - wykorzystuj multimodal capabilities
- Kombinuj różne "moce" (voice + visual + code) dla max produktywności
- Automatyzuj powtarzalne zadania (commits, tests, docs)
- Eksperymentuj - odkrywaj nowe workflow'y pasujące do Twojego stylu pracy

---

### **Podsumowanie Modułu 1**

Ten moduł daje solidne **fundamenty** do pracy z Claude Code:
*   **Mentalny model** – rozumiesz czym Claude Code jest i czym różni się od chatbotów w IDE
*   **Setup środowiska** – masz zainstalowane narzędzie, skonfigurowany terminal i aliasy
*   **Efektywny workflow** – znasz składnię `@`, slash commands, zarządzanie kontekstem
*   **Podstawy bezpieczeństwa** – wiesz że Claude pyta o uprawnienia i działa w sandboxie

**Następny krok:** Moduł 2 zagłębi się w **Bezpieczeństwo i Uprawnienia**, ucząc jak bezpiecznie konfigurować Claude Code, chronić wrażliwe pliki i mądrze zarządzać trybami uprawnień.